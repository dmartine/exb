<!-- TOC -->

<ul>
<li><a href="#what-is-widget">What is Widget</a></li>
<li><a href="#widget-folder-structure">Widget folder structure</a></li>
<li><a href="#skills-required">Skills required</a></li>
<li><a href="#recommended-development-tool">Recommended development tool</a></li>
<li><a href="#jimu">Jimu</a><ul>
<li><a href="#what-is-jimu">What is Jimu?</a></li>
<li><a href="#jimu-packages">Jimu packages</a></li>
</ul>
</li>
<li><a href="#how-to-develop-a-widget">How to develop a widget</a><ul>
<li><a href="#get-started">Get started</a></li>
<li><a href="#demo-widget">Demo widget</a></li>
<li><a href="#try-the-demo-widget">Try the demo widget</a></li>
<li><a href="#create-a-widget">Create a widget</a></li>
</ul>
</li>
<li><a href="#create-a-setting-ui-for-widget">Create a setting UI for widget</a></li>
<li><a href="#create-ui-for-widget">Create UI for widget</a></li>
<li><a href="#i18n-support">i18n support</a></li>
<li><a href="#use-datasource">Use Datasource</a><ul>
<li><a href="#datasource">Datasource</a></li>
<li><a href="#datasource-in-the-app-config">Datasource in the app config</a></li>
<li><a href="#use-datasource-in-a-widget">Use datasource in a widget</a></li>
<li><a href="#use-repeated-datasource">Use repeated datasource</a></li>
<li><a href="#share-data-between-widgets">Share data between widgets</a></li>
<li><a href="#widget-generated-datasource">Widget generated datasource</a></li>
<li><a href="#samples">Samples</a></li>
</ul>
</li>
<li><a href="#use-modules-in-arcgis-api-for-javascript">Use modules in ArcGIS API for JavaScript</a></li>
<li><a href="#communication-between-widgets">Communication between widgets</a><ul>
<li><a href="#share-the-same-data-source">Share the same data source</a></li>
<li><a href="#consume-the-output-datasource-generated-by-another-widget">Consume the output datasource generated by another widget.</a></li>
<li><a href="#by-message-action">By message action</a></li>
</ul>
</li>
<li><a href="#server-side-rendering-ssr">Server-Side Rendering (SSR)</a><ul>
<li><a href="#how-to-enable-ssr">How to enable SSR?</a></li>
<li><a href="#what-can-be-rendered-by-the-server">What can be rendered by the server?</a></li>
<li><a href="#how-to-make-widget-supporting-ssr">How to make widget supporting SSR?</a></li>
<li><a href="#limitaion-of-ssr">Limitaion of SSR</a></li>
</ul>
</li>
<li><a href="#support-inline-editing">Support inline editing</a></li>
<li><a href="#create-a-layout-widget">Create a layout widget</a><ul>
<li><a href="#setup-a-layout-widget">Setup a layout widget</a></li>
<li><a href="#structure-of-the-layout">Structure of the layout</a></li>
<li><a href="#demo-layout-widget">Demo layout widget</a><ul>
<li><a href="#decide-how-to-arrange-its-items">Decide how to arrange its items</a></li>
<li><a href="#design-the-settings-of-the-layout-and-the-layout-item">Design the settings of the layout and the layout item</a></li>
<li><a href="#folder-structure-of-a-layout">Folder structure of a layout</a></li>
<li><a href="#runtime-of-the-layout">Runtime of the layout</a><ul>
<li><a href="#layout-item">Layout item</a></li>
<li><a href="#layout">Layout</a></li>
</ul>
</li>
<li><a href="#builder-of-the-layout">Builder of the layout</a><ul>
<li><a href="#layout-item-1">Layout item</a></li>
<li><a href="#layout-1">Layout</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#wrap-layout-widget-in-widget">Wrap layout widget in widget</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="what-is-widget">What is Widget</h1>
<p>A widget is a configurable functional unit. It&#39;s the building block used to create pages for an experience. An experience is a web app or web page created by Experience Builder (ExB). A widget usually provides a setting UI so you can configure its functionalities in the builder environment. If a widget has configurable options but no setting UI, you may use a JSON editor to configure it.</p>
<h1 id="widget-folder-structure">Widget folder structure</h1>
<p>A widget consists of the following files:</p>
<ul>
<li>src: The widget source code folder.<ul>
<li>runtime: folder<ul>
<li>widget.tsx: main entry file</li>
<li>assets: folder, for assets used by widget.tsx</li>
<li>translations:</li>
</ul>
</li>
<li>setting: folder<ul>
<li>setting.tsx</li>
<li>assets: folder</li>
<li>translations</li>
</ul>
</li>
</ul>
</li>
<li>dist: The compiled code folder of the widget. It uses the same structure as the source code folder.</li>
<li>icon.svg(png)</li>
<li>config.json: The widget&#39;s default config</li>
<li>manifest.json: See <a href="">jimu-core/lib/types/manifest</a> for details.</li>
</ul>
<h1 id="skills-required">Skills required</h1>
<p>To develop a widget, you need a basic understanding of the following:</p>
<ul>
<li>TypeScript</li>
<li>React</li>
<li><a href="#jimu">Jimu</a></li>
</ul>
<p>Further, it would be very helpful if you become proficient in the following:</p>
<ul>
<li>Bootstrap</li>
<li>Redux</li>
<li>Seamless-immutable</li>
</ul>
<h1 id="recommended-development-tool">Recommended development tool</h1>
<p>Visual Studio Code with the following extensions:</p>
<ul>
<li>IntelliSense for CSS class names in HTML</li>
<li>vscode-styled-components</li>
</ul>
<h1 id="jimu">Jimu</h1>
<h2 id="what-is-jimu-">What is Jimu?</h2>
<p>Jimu is a JavaScript library to create a configurable experience.</p>
<h2 id="jimu-packages">Jimu packages</h2>
<p>Jimu library consists of these packages:</p>
<ul>
<li><p><strong>Jimu-core</strong>:
This package loads and parses the app config, then loads the layout, theme, and widgets based on the app config. In order to support this, jimu-core defines several classes like WidgetManager, ConfigManager and ThemeManager, etc. In addition, the <code>jimu-core</code> defines BaseWidget, some common types, and some extension points, which are subject to be extended by other packages and widgets. An experience based on jimu should load jimu-core package.</p>
</li>
<li><p><strong>jimu-layouts</strong>:
This package contains common implementations for layout widgets.</p>
</li>
<li><p><strong>jimu-ui</strong>:
This package is designed to contain all UI components that experiences will utilize. Under the hood, it uses <code>reactstrap</code>. Additionally, more components that are not in <code>reactstrap</code> will be added.</p>
</li>
<li><p><strong>jimu-arcgis</strong>:
This package is designed to contain all components that require the ArcGIS API for JavaScript 4.x to run.</p>
</li>
<li><p><strong>jimu-for-builder</strong>:
This package is designed to support developing the widget setting page.</p>
</li>
</ul>
<h1 id="how-to-develop-a-widget">How to develop a widget</h1>
<h2 id="get-started">Get started</h2>
<ul>
<li>To clone the repository, please follow the README in the repository.</li>
<li>If you have a release package, do the followings:<ul>
<li>cd <code>server</code></li>
<li>run <code>npm ci</code></li>
<li>run <code>node src/server</code></li>
<li>cd <code>client</code></li>
<li>run <code>npm ci</code>. If you encounter error something like <code>can&#39;t find Python</code> when run <code>npm ci</code>, please run <code>npm install --global windows-build-tools</code> firstly.</li>
<li>create a widget under <code>your-extensions/widgets</code> folder. To have a quick try, you can copy the demo widget and rename it.</li>
<li>run <code>npm start</code></li>
</ul>
</li>
</ul>
<h2 id="demo-widget">Demo widget</h2>
<p>To get started, please refer to the <em>demo</em> widget: [client/sample-widgets/demo]</p>
<h2 id="try-the-demo-widget">Try the demo widget</h2>
<ul>
<li>Open <code>https://&lt;domain&gt;:3001/</code></li>
<li>Create a new experience</li>
<li>Add the demo widget in the builder</li>
</ul>
<h2 id="create-a-widget">Create a widget</h2>
<ul>
<li>Create the required files.<ul>
<li>The easiest way is to make a copy from the demo widget.</li>
<li>After you rename the demo widget, please make sure to change the <code>name</code> in the <code>manifest.json</code> file.</li>
</ul>
</li>
<li>Since a widget is basically a react component, you can implement the widget&#39;s logic by overriding the component lifecycle methods, such as <code>render</code>, <code>componentDidUpdate</code>, etc. Although you can render anything you want in the <code>render</code> method, you need to make sure your widget can work well with the theme, please read the <a href="#create-ui-for-widget">Create UI for widget</a> section for further details.</li>
<li>The widget component must extend from the <code>BaseWidget</code> class, which is exported from the <code>jimu-core</code> package.</li>
<li>There are many <code>props</code> injected into a widget. You can access them through <code>this.props</code>. For all available properties, please see <code>jimu-core/lib/types/props</code>;</li>
<li>To access the properties that are not in <code>this.props</code>, you can define a static property in the widget class: <code>mapExtraStateProps: (state: IMState, ownProps) =&gt; IMState</code>.</li>
<li>To support <code>i18n</code>, please put your translations for the strings used in the widget in the <code>translations</code> folder. See <a href="#i18n-support">I18n Support</a>.</li>
<li>How to use Web Map, Web Scene, Feature Layer?<ul>
<li>Web Map/Web Scene/Feature Layers can be accessed through Datasource. See <a href="#use-datasource">Use datasource</a></li>
</ul>
</li>
<li>How to use modules in ArcGIS API for JavaScript?<ul>
<li><a href="#use-modules-in-arcgis-api-for-javascript">Use modules in ArcGIS JS API</a></li>
</ul>
</li>
<li>Best practice:<ul>
<li>Give widget a root CSS class name, use <code>widget-&lt;widget name&gt;</code> as the widget&#39;s class name, use <code>widget-setting-&lt;widget name&gt;</code> as the widget setting&#39;s class name.</li>
<li>To make widget config type safe, you can create a type file in the widget <code>src</code> folder and use it in both <code>widget.tsx</code> and <code>setting.tsx</code>.</li>
<li>To use the 3rd party libraries built in jimu-core, use <code>import {} from &#39;jimu-core&#39;</code>. For Example: <code>import {React} from &#39;jimu-core</code>; If using <code>import {} from &#39;3rd_lib&#39;</code>, the size of your widget will be larger since the lib will be built into your widget.</li>
<li>To use UI components, use <code>import {} from &#39;jimu-ui&#39;</code></li>
</ul>
</li>
</ul>
<h1 id="create-a-setting-ui-for-widget">Create a setting UI for widget</h1>
<ul>
<li>Creating the setting UI for a widget is similar to creating a widget, except that you need to name the file as <code>setting.tsx</code> and put it in the setting folder.</li>
<li>The setting component must extend from the <code>BaseWidgetSetting</code>class, which is exported from the <code>jimu-for-builder</code> package.</li>
<li>When the widget is configured in the setting UI, it can call <code>this.props.onSettingChange()</code> to notify the changes.</li>
</ul>
<h1 id="create-ui-for-widget">Create UI for widget</h1>
<ul>
<li><p><strong>Use the out-of-box UI components from <em>jimu-ui</em> whenever you can</strong>
-
<em>jimu-ui</em> includes:</p>
<ul>
<li><a href="http://reactstrap.github.io/components/buttons/">components from Reactstap(the React version of Bootstrap)</a></li>
<li><a href="jimu-ui/lib/components">ExB&#39;s own UI components</a></li>
</ul>
<p>By doing so, the widget is ensured to have a consistent look and feel with the rest of the ExB system, and benefits from the theming system as well.</p>
<p>The UI components can be imported, for example: <code>import {Button, Modal} from &#39;jimu-ui&#39;;</code>.</p>
<p>Access this link to view the UI components and icons: <code>https://&lt;domain&gt;:3001/theme-builder</code></p>
</li>
<li><p><strong>Utilize Bootstrap utility classes</strong>
Instead of writing your own CSS utility/helper classes, please use the <a href="https://hackerthemes.com/bootstrap-cheatsheet/#flex-wrap">ones provided by Bootrap</a>, which covers:</p>
<ul>
<li>Display</li>
<li>Flexbox</li>
<li>Spacing</li>
<li>Sizing</li>
<li>Text</li>
</ul>
<p>For example:
To make a div float to left:</p>
<pre><code class="language-html">&lt;div className=&#39;float-left&#39;&gt;
text
&lt;/div&gt;</code></pre>
<p>or to make a div have full width, rounded borders, and dark background:</p>
<pre><code class="language-html">&lt;div className=&#39;w-100 rounded bg-dark&#39;&gt;
text
&lt;/div&gt;</code></pre>
<p>For more samples, <a href="https://www.w3schools.com/bootstrap4/bootstrap_utilities.asp">visit here</a>.</p>
<ul>
<li><p><strong>Theming a widget:</strong>
You can utilize the theming system provided by ExB to either theme your widgets or UI components.</p>
<p><strong>Access theme Variables:</strong></p>
<ul>
<li>Within an ExB widget(extends from <code>BaseWidget</code>) :
Call <code>this.props.theme</code></li>
<li><p>Within a React component:
import <code>withTheme</code> and wrap your component:</p>
<pre><code>import { IThemeVariables, themeUtils } from &#39;jimu-core&#39;;

interface Props {
  ..
  theme?: IThemeVariables;
}

class _YourComponent extends React.PureComponent&lt;Props&gt; {
...
}
export const YourComponent = themeUtils.withTheme(_YourComponent);</code></pre></li>
</ul>
<p>Then call <code>this.props.theme</code> in the component to access the theme variables.</p>
<p>To view theme variable definitions, go to: <code>client/jimu-core/lib/types/theme.ts</code></p>
<p><strong>CSS-in-JS:</strong>
<em>CSS-in-JS</em> is the way to go when it comes to style UI elements in ExB. The library chosen is <a href="https://emotion.sh/">Emotion JS</a>, which provides two major patterns:</p>
<ul>
<li><p><strong><a href="http://emotion.sh/docs/css-prop">CSS prop</a> (Recommended)</strong>:</p>
<p>Allows you to style a widget in the fashion of regular CSS as <strong>string (template literal)</strong>:</p>
<pre><code>/** @jsx jsx */
import { css, jsx } from &#39;jimu-core&#39;;
...
render(
  const style = css`
    color: ${this.props.theme.colors.danger};
    font-size: 1.25rem;
  `;

  return &lt;div css={style}&gt;
    This is your widget
  &lt;/div&gt;;
)</code></pre><p>Result:</p>
<img width="157" alt="screen shot 2018-12-28 at 8 36 02 pm" src="https://devtopia.esri.com/storage/user/967/files/da0701b0-0ae0-11e9-81fe-dfdc8729291f">


</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>  Or as **object**:

  ```
  import { css, jsx } from &#39;jimu-core&#39;;
  ...
  render(
    const style = {
      backgroundColor: this.props.theme.colors.gray300,
      padding: &#39;1rem&#39;
    };

    return &lt;div css={style}&gt;
      This is your widget
    &lt;/div&gt;;
  )
  ```

  Result:

  &lt;img width=&quot;149&quot; alt=&quot;screen shot 2018-12-28 at 8 36 11 pm&quot; src=&quot;https://devtopia.esri.com/storage/user/967/files/23883ff2-0ae1-11e9-9e77-9b21003da4ef&quot;&gt;

  &gt;NOTE:

  &gt;Make sure to include the jsx pragma at the top of your file when using **the CSS prop**:

  &gt;```/** @jsx jsx */```

- **[Styled components](https://emotion.sh/docs/styled)**:

  If you have used [Styled-Components](https://www.styled-components.com/) library before, you should be very familiar with this approach:

  ```
  import {styled} from &#39;jimu-core&#39;;
  ...
  render(
    const StyledButton = styled.button`
      color: white;
      background-color: ${this.props.theme.colors.primary};
      transition: 0.15s ease-in all;
      &amp;:hover {
        background-color: ${this.props.theme.colors.danger};
      }
    `;

    return &lt;StyledButton&gt;
      A styled HTML Button
    &lt;/StyledButton&gt;;
  )
  ```

  Result:

  &lt;img width=&quot;156&quot; alt=&quot;screen shot 2018-12-28 at 8 36 29 pm&quot; src=&quot;https://devtopia.esri.com/storage/user/967/files/3a746c22-0ae1-11e9-83ef-bac820614bda&quot;&gt;


  You can use this approach to restyle a React component such as:
  ```
  import {styled} from &#39;jimu-core&#39;;
  import { Button } from &#39;jimu-ui&#39;;
  ...
  render(
    const StyledBSButton = styled(Button)`
      background-color: hotpink !important;
      border: 0 !important;
      transition: 0.15s ease-in all;
      &amp;:hover {
        background-color: purple !important;
      }
    `;

    return &lt;StyledBSButton&gt;
      A re-styled Button Component
    &lt;/StyledBSButton&gt;;
  )
  ```

  Result:

  &lt;img width=&quot;241&quot; alt=&quot;screen shot 2018-12-28 at 8 36 36 pm&quot;   src=&quot;https://devtopia.esri.com/storage/user/967/files/53f20aa6-0ae1-11e9-96ed-36198c66ea62&quot;&gt;

### Do you need to use regular CSS class names?
You can still utilize the regular CSS class names to style your widgets using Emotion JS:
```
import { css, jsx } from &#39;jimu-core&#39;;
...
render(
  const styleTag = `
    .danger-color {
      color: red;
    }
  `;

  return &lt;div&gt;
    &lt;style&gt;
      {styleTag}
    &lt;/style&gt;
    &lt;p className=&quot;danger-color&quot;&gt;
      Text color is from a named CSS class
    &lt;/p&gt;
  &lt;/div&gt;
)
```</code></pre><ul>
<li><p><strong>Using SVG</strong>
There are two ways to use an SVG image in the widget: as an <code>&lt;svg&gt;</code> tag or as an <code>&lt;img&gt;</code> tag.</p>
<p><strong>As <code>&lt;svg&gt;</code> (for icons):</strong>
If you are using svg images as icons, use the <code>&lt;svg&gt;</code> tag to embed an icon in your widget. This way, you have more control over its appearances, such as, its fill color or the ability to target a child element inside of the svg icon.</p>
<p>ExB automatically converts any svg files inside of <code>path/to/yourwidget/src/runtime/assets/icons</code> or <code>path/to/yourwidget/src/setting/assets/icons</code>, or a svg file specifically named as <code>icon.svg</code> at the root of <code>path/to/yourwidget/src/setting/assets/</code> folder, as components which can be imported in your widget, and used in the <code>Icon</code> component as:</p>
<pre><code>import { Icon } from &#39;jimu-ui&#39;;
...
const SVGIcon = requrie(&#39;./assets/icons/DemoIcon.svg&#39;);
...
&lt;Icon icon={SVGIcon} /&gt;</code></pre><p>The icon will render as a <code>&lt;svg&gt;</code> element.</p>
<p><strong>As <code>&lt;img&gt;</code>:</strong>
A SVG image can also be directly displayed as an <code>&lt;img&gt;</code>. In ExB, the stored SVG images other than the paths mentioned in the &quot;Using SVG&quot; section are encoded to data in base64 format and attached to the &quot;src&quot; property of the <code>&lt;img&gt;</code> tag, or the &quot;icon&quot; property of the <code>&lt;Icon&gt;</code> component.</p>
<p>To use an SVG image as an <code>&lt;img&gt;</code>:</p>
<pre><code>&lt;img src={require(&#39;./path/to/assets/SVGImage.svg&#39;)} /&gt;
or
&lt;Icon icon={require(&#39;./path/to/assets/SVGImage.svg&#39;)} /&gt;</code></pre></li>
</ul>
<h1 id="i18n-support">i18n support</h1>
<ul>
<li><code>react-intl</code> is used to support i18n.</li>
<li>To support i18n, declare supported languages in your widget&#39;s manifest.json by <code>supportedLocales</code>.</li>
<li>The translation strings should be put in the <code>runtime/translations</code> and <code>setting/translations</code> folders.</li>
<li>In this folder, there should be a <code>default.ts</code> file, which is used to define the default strings. You can import this file into your widget and use it as the default message.</li>
<li>In <code>widget.tsx</code>, you have two ways to access the translated strings:<pre><code>this.props.intl.formatMessage({id: &#39;_widgetLabel&#39;, defaultMessage: defaultMessages._widgetLabel})}</code></pre>or<pre><code>&lt;FormattedMessage id=&quot;widgetName&quot; defaultMessage={defaultMessages.widgetName}/&gt;</code></pre></li>
</ul>
<h1 id="use-datasource">Use Datasource</h1>
<h2 id="datasource">Datasource</h2>
<p>Datasource defines how your widget accesses data. When data is from a remote server, the widget can use a datasource class to query the data to the client side; when data is generated by a widget, it can be used by another widget by putting itself into a datasource class.</p>
<p>There is a <code>DataSource</code> interface defined in <code>jimu-core</code> package, which defines some common methods such as <code>getRecords()</code>, <code>getSelectedRecords()</code>. There are different types of datasources, and each of them has its own way to get/select data records. For example, <code>FeatureLayerDataSource</code> queries data from a feature service, <code>ItemDataSource</code> queries data from ArcGIS Portal REST API. You can create your own datasource by implementing the <code>DataSource</code> interface or extend the <code>AbstractDataSource</code> class. In addition to the common <code>DataSource</code> interface, there is another common interface <code>QueriableDataSource</code> and its abstract class <code>AbstractQueriableDataSource</code>. This interface has properties including <code>url</code>, <code>load</code>, <code>query</code>, and <code>addRecord</code> etc., The difference between the <code>load</code> and <code>query</code> methods is: <code>load</code> updates the <code>records</code> property and the status of the datasource while <code>query</code> queries and returns the records only.</p>
<p>A datasource can have sub datasources. As a result, you may pack more than one datasource to make it easier to use. This kind of datasource is called a <code>DataSourceSet</code>. <code>WebMapDataSource</code> is a <code>DataSourceSet</code>. <code>DataSourceSet</code> is also a type of datasource when the <code>isDataSourceSet</code> property is set to <code>true</code>.</p>
<p>Datasource is managed by the <code>DataSourceManager</code>, this allows you to use the <code>DataSourceManager</code> to create or get datasources.</p>
<p>There are many classes in ArcGIS API for JavaScript managing or showing features. These classes are wrapped as datasources in the <code>jimu-arcgis</code> package. For example: <code>WebMapDataSource</code>, <code>MapViewDataSource</code>, <code>FeatureLayerViewDataSource</code> and <code>FeatureLayerDataSource</code>, etc. Therefore, use the <code>DataSourceManager</code> to get the corresponding datasources.</p>
<p>To make a datasource easy to use, we define a <code>DataSourceComponent</code> component which accepts the <code>IMUseDataSource</code> property and returns the datasource object and its status info with a callback. It also accepts a function as its child. In this function, you can get the datasource object and datasource info to render the data in the datasource. In addition, it accepts an optional <code>query</code> property and reloads the data when the query is changed. If you just need to query data, you can use <code>DataQueryComponent</code>, this component has the similar interface with <code>DataSourceComponent</code> but calls <code>query</code> internally.</p>
<h2 id="datasource-in-the-app-config">Datasource in the app config</h2>
<p>All datasources in an experience are saved in the <code>dataSources</code> properties of the app config.</p>
<h2 id="use-datasource-in-a-widget">Use datasource in a widget</h2>
<ul>
<li>To use a datasource in a widget, you must declare the datasource in the app config by the config property <code>useDataSources</code>, see <code>WidgetJson.useDataSources</code>. To do this, you should provide a setting UI to select a datasource. In the setting UI, you should use <code>ChooseDataSource</code> component to select datasources.</li>
<li>At runtime use <code>DataSourceComponent</code> to get the datasource object and datasource info. The info includes the followings:<ul>
<li>status: whether the data is loading or loaded for quarriable datasources, connected or disconnected for the push datasources.</li>
<li>saveStatus: whether the data is saving or saved for the editable datasource</li>
<li>selectedIndexes: the selected data indexes</li>
<li>selectedIds: the selected data IDs</li>
<li>version: the version number is to manage the data change in the client side, so all the datasource consumers can know when the data is changed.</li>
</ul>
</li>
<li>The selected datasource ids/indexes can be put in the URL as a query parameter. To do this, you can use <code>datasource.selectRecord</code> or <code>datasource.selectRecordById</code>.</li>
<li>Use <code>MapView</code>/<code>SceneView</code> in a widget<ul>
<li>In many cases, a widget needs to work with a map view/scene view, and to access layers in the views as well. The recommended way is:<ul>
<li>In the widget setting UI, declare the layer type datasource in <code>ChooseDataSource</code>, such as <code>FEATURE_LAYER_VIEW</code>.</li>
<li>In the widget, use <code>DataSourceComponent</code> to get the datasource object</li>
<li>To access map/scene, use <code>layerViewDataSource.getRootViewDataSource()</code></li>
</ul>
</li>
</ul>
</li>
<li>Use <code>WebMap</code>/<code>WebScene</code> in widget<ul>
<li>It is similar to use <code>MapView</code>/<code>SceneView</code>, but use <code>WebMapDataSource</code>/<code>WebSceneDataSource</code> instead of <code>WebMapViewDataSource</code>/<code>WebSceneViewDataSource</code></li>
</ul>
</li>
<li>Use <code>FeatureLayer</code> in widget<ul>
<li>Use <code>FeatureLayerDataSource</code>.</li>
</ul>
</li>
</ul>
<h2 id="use-repeated-datasource">Use repeated datasource</h2>
<p>In addition to access datasource by <code>DataSourceComponent</code>, a widget can access repeated datasource by <code>this.props.repeatedDataSource</code>. In the repeated datasource, you can get the datasource&#39;s <code>id</code>, <code>record</code>, and <code>recordIndex</code>. Any widget can provide repeated datasource by using <code>RepeatedDataSourceProvider</code>, <code>List</code> widget is a good example that provides repeated datasource. To use repeated datasource, you need to add the <code>supportRepeat</code> property in your widget&#39;s manifest.</p>
<ul>
<li><p>What&#39;s repeated datasource?
The datasource provided by <code>RepeatedDataSourceProvider</code> is called a repeated datasource. All children widgets of the widget that provide a datasource will receive the repeated datasource. This is similar to the React&#39;s Context.</p>
</li>
<li><p>Which widgets support context datasource for now?
For now, the <code>List</code> widget can provide datasource and the <code>Text</code>, <code>Link</code> and <code>Image</code> widget can consume datasource.</p>
</li>
</ul>
<h2 id="share-data-between-widgets">Share data between widgets</h2>
<p>It&#39;s a common scenario that multiple widgets share the same data. A good example is the <code>Detail</code> widget which shows the <code>List</code> widget&#39;s current selection. The easiest way to accomplish this is to declare both widgets with the same datasource. For instance, when an item is selected in the <code>List</code> widget, the widget will call <code>datasource.selectRecord()</code> to update the datasource status in the app store. This will allow the <code>Detail</code> widget to render the current selected item accordingly. In addition, the current selected item will be put in the URL so the current app state can be shared to others.</p>
<h2 id="widget-generated-datasource">Widget generated datasource</h2>
<ul>
<li>A widget can generate datasources, which can be used by other widgets. To accomplish this, you must declare the generated datasources in the app config using the <code>outputDataSources</code> property and set the datasource definition in the <code>dataSources</code> property. Generally, this is done in the widget setting UI.</li>
<li>When a widget declares a generated datasource, the widget at runtime should create that datasources accordingly.</li>
</ul>
<h2 id="samples">Samples</h2>
<ul>
<li>There are sample widgets in <code>widgets/samples/data-sources</code>, and the <code>use-feature-layer-widget</code> widget is available in builder.</li>
<li>There are some sample configs in <code>stemapp/ds</code>. Access <code>https://&lt;domain&gt;:30001/stemapp/?config=configs/ds/config-ds1.json</code> to give it a try.</li>
</ul>
<h1 id="use-modules-in-arcgis-api-for-javascript">Use modules in ArcGIS API for JavaScript</h1>
<p>By default, the ArcGIS API for JavaScript is not loaded when the app loads. To utilize API modules in the widget, you have two options:</p>
<ul>
<li>If your widget depends on JSAPI heavily (almost nothing can be done without JSAPI)<ul>
<li>Declare <code>jimu-arcgis</code> dependency in the widget&#39;s manifest.json file</li>
<li>In <code>widget.tsx</code>, use <code>import Map = require(&#39;esri/Map&#39;)</code></li>
</ul>
</li>
<li>If your widget depends on JSAPI conditionally (can do something without JSAPI)<ul>
<li>In <code>widget.tsx</code>, use <code>loadArcGISJSAPIModules([])</code> to dynamically load modules</li>
</ul>
</li>
</ul>
<h1 id="communication-between-widgets">Communication between widgets</h1>
<p>A widget is a functional unit. You can make various function units work together to complete a task by enabling communication between widgets. Below are the three ways to enable communication:</p>
<h2 id="share-the-same-data-source">Share the same data source</h2>
<p>see <a href="#share-data-between-widgets">Share data between widgets</a></p>
<h2 id="consume-the-output-datasource-generated-by-another-widget-">Consume the output datasource generated by another widget.</h2>
<p>Every widget can generate outputs, which can be consumed by other widgets. Let’s say widget A consumes the output of widget B. Once widget B updates its output, widget A will be updated simultaneously. A good example of this would be a Query widget that generates a feature set, which is used as the input of a GP widget.
See <a href="#widget-generated-datasource">Widget generated datasource</a></p>
<h2 id="by-message-action">By message action</h2>
<p>Every widget can publish messages that are defined in Jimu and register message actions. Widgets can communicate with each other through these messages.</p>
<ul>
<li>What&#39;s a message?
A message is the information published by a widget.</li>
<li>What&#39;s message type?
Messages are classified by the message types, and each type defines some properties. For example, an <code>ExtentChange</code> message carries an <code>extent</code> property.</li>
<li>What&#39;s message action?
Message action is a piece of code that executes when a widget receives a message.</li>
<li>What message types are available in Jimu?
To make the message and the message action configurable, we define some message types in Jimu. See <code>MessageType</code> in <code>jimu-core</code>.</li>
<li><p>How to publish a message?
A widget calls <code>MessageManager.getInstance().publishMessage(message)</code> to publish a message. For example, the List widget publishes the <code>DataRecordsSelectionChange</code> message when a list item is clicked, or a bookmark widget publishes the <code>ExtentChange</code> message when a bookmark item is clicked.</p>
<p>A Widget should declare the published messages in the <code>manifest.json</code> file.</p>
</li>
<li><p>How to register message actions?
A widget should declare all actions in the <code>manifest.json</code> file. Once a widget is added to the app, its actions will be registered by Jimu.</p>
</li>
<li><p>The action interface
See code <code>MessageAction</code></p>
</li>
<li><p>How are actions executed?
Actions will not be executed by default, even when there are correct messages published. You need to configure a widget to specify what actions should be executed when it receives a particular message type.</p>
</li>
<li><p>Sample app: <code>https://&lt;domain&gt;:3001/stemapp/?config=configs/config-widget-communication.json</code></p>
</li>
</ul>
<h1 id="server-side-rendering-ssr-">Server-Side Rendering (SSR)</h1>
<p>The experience created by ExB does not require any server-side functions to run. This means it can be deployed to any web server like Apache, IIS, etc. However, taking the advantage of <code>ReactDOMServer.renderToString</code>, ExB has an optional feature that can render the experience on a Node server.</p>
<h2 id="how-to-enable-ssr-">How to enable SSR?</h2>
<ul>
<li>Use the Node server included in ExB:
<code>npm run serve:ssr</code> or <code>node src/server -s</code> (for release package)</li>
</ul>
<h2 id="what-can-be-rendered-by-the-server-">What can be rendered by the server?</h2>
<ul>
<li>The experience contents. Once they are rendered on the server-side, they can be indexed by the search engine, and can be loaded quickly.</li>
<li>Some meta tags. They can be read by social media sites to understand the metadata of the experience.</li>
</ul>
<h2 id="how-to-make-widget-supporting-ssr-">How to make widget supporting SSR?</h2>
<ul>
<li>A widget is a React component, so only the widget&#39;s <code>constructor</code> and <code>render</code> lifecycle methods will be called on the server-side. So, if you don&#39;t use the browser environment variables, such as <code>document</code>, <code>history</code>, etc., in these methods, your widget should work well on the server-side. If you use them, the render will break. Alternatively, the <code>window</code> object is available to use on the server-side. However, the <code>window</code> object has these properties only on the server:<ul>
<li>SystemJS</li>
<li>fetch</li>
<li>jimuConfig</li>
<li>location</li>
</ul>
</li>
<li>It&#39;s difficult for a widget to render async data. To make it easy, you can define a static method <code>preloadData</code> in your widget. In this method, you can fetch data and then return the desired props, which will be injected to your widget&#39;s <code>this.props</code>.</li>
</ul>
<h2 id="limitaion-of-ssr">Limitaion of SSR</h2>
<ul>
<li>To make <code>fetch</code> work on the server-side, the URL to fetch needs to be absolute, such as <code>https://&lt;domain&gt;/path</code>.</li>
<li>Widgets that depend on the ArcGIS API for JavaScript do not support SSR.</li>
</ul>
<h1 id="support-inline-editing">Support inline editing</h1>
<p>Every configurable widget can provide a setting page to let users configure the widget. However, some configurations are easier to operate on the widget-self and not on the widget&#39;s setting page. In this workflow, a widget can support this feature by providing inline editing capability.</p>
<p>There are some ways to support inline editing:</p>
<ul>
<li>Declare <code>supportInlineEditing</code> in the widget&#39;s <code>manifest.json</code>. In this instance, the widget will have an edit toolbar when the widget is launched in builder. <code>Text</code> widget is implemented this way.</li>
<li>Declare <code>hasEmbeddedLayout</code> in widget&#39;s <code>manifest.json</code>. In this case, the widget should use a layout component to ensure users can drag &amp; drop other widgets in/out of the widget. For performance reasons, the layout component for viewer is <code>LayoutViewer</code> and is from <code>jimu-layout</code>, and the layout component for builder is <code>this.props.builderSupportModules.LayoutClass</code>, which is from <code>jimu-layout</code>. This appraoch allow us to inject the layout component into builder for easy use. <code>List</code> widget uses this technique.</li>
<li>Declare <code>CONTEXT_TOOL</code> extensions in widget&#39;s <code>manifest.json</code>. The declared extensions will be available in the selection toolbar. <code>Image</code> widget is used in this way.</li>
</ul>
<p>To support inline editing, the widget may have some modules that are required only when the widget is launched in builder. In this case, you can put these modules in <code>builder-support.tsx</code>. This file should be in the same folder with <code>widget.tsx</code>. The modules in this file will be available in <code>this.props.builderSupportModules.widgetModules</code> when the widget is launched in builder.</p>
<h1 id="create-a-layout-widget">Create a layout widget</h1>
<p>Layout widget is a container for other widgets and sections. It is responsible for the following:</p>
<ol>
<li>Decides how to arrange its items.</li>
<li>Designs the settings of the layout if necessary.</li>
<li>Designs the settings for its items if necessary.</li>
<li>Provides two sets of UI/UX for design and preview mode.<ul>
<li>Implements the behavior of item arrangement for runtime and drag-and-drop functionality for the builder.</li>
</ul>
</li>
</ol>
<h2 id="setup-a-layout-widget">Setup a layout widget</h2>
<p>Set <code>type</code> to <code>Layout</code> and <code>layouts</code> required by the layout widget in the <code>properties</code> of the widget&#39;s <strong>manifest.json</strong>. Then the framework will create an empty layout for your widget.</p>
<pre><code>&quot;properties&quot;: {
  &quot;type&quot;: &quot;LAYOUT&quot;,
  &quot;layouts&quot;: [{
    &quot;name&quot;: &quot;DEFAULT&quot;,
    &quot;label&quot;: &quot;Default&quot;,
    &quot;type&quot;: &quot;ROW&quot;
  }]
}</code></pre><h2 id="structure-of-the-layout">Structure of the layout</h2>
<p>A layout is a JSON structure saved in your app&#39;s configuration file.</p>
<pre><code>{
  layouts: {
    [id_of_layout]: {
      order: [], // sorted id array of its children
      content: {
        [id_of_layout_item]: {
          id: string,
          bbox: { // position and size of the item
            left,
            right,
            top,
            bottom,
            width,
            height
          },
          setting: { // setting of the layout item, defined by the developer
            ...,
            style?: {} // css style for the layout item
          }
        },
        ..., // more layout items
      }
      setting: { // setting of the layout, defined by the developer
        ...,
        style?: {} // css style for the layout
      }
    }
  }
}</code></pre><h2 id="demo-layout-widget">Demo layout widget</h2>
<p>We will use the out of the box <code>Row Widget</code> as an example. First, we need to create a <em>row</em> layout. Then make it as a widget.</p>
<h3 id="decide-how-to-arrange-its-items">Decide how to arrange its items</h3>
<p>We want to create a layout widget in which every item is lined horizontally without wrap and overlap. Each item can have its own size and we will use <code>flexbox</code> of CSS3 to implement it.</p>
<h3 id="design-the-settings-of-the-layout-and-the-layout-item">Design the settings of the layout and the layout item</h3>
<p>Since we will use <code>flexbox</code> of CSS3, you can take the layout as a flexbox container, and the layout item as a flexbox item.
The setting of the layout includes:</p>
<ul>
<li>justify-content: &#39;flex-start&#39; | &#39;flex-end&#39; | &#39;center&#39; | &#39;space-between&#39; | &#39;space-around&#39; | &#39;space-evenly&#39;</li>
<li>align-items: &#39;stretch&#39; | &#39;flex-start&#39; | &#39;flex-end&#39; | &#39;center&#39;</li>
</ul>
<p>The setting of the layout item includes:</p>
<ul>
<li>bbox: {width: number, height: number}</li>
<li>flex-grow: number</li>
<li>flex-shrink: number</li>
<li>align-self: &#39;auto&#39; | &#39;flex-start&#39; | &#39;flex-end&#39; | &#39;center&#39; | &#39;stretch&#39;;</li>
</ul>
<h3 id="folder-structure-of-a-layout">Folder structure of a layout</h3>
<p>We recommend the following folder structure for your layout:</p>
<pre><code>[layout_name]
  |- builder
    |- layout-item.tsx
    |- layout.tsx
  |- runtime
    |- layout-item.tsx
    |- layout.tsx</code></pre><h3 id="runtime-of-the-layout">Runtime of the layout</h3>
<h4 id="layout-item">Layout item</h4>
<p>A layout item in runtime is used to render a widget or section taking the setting of the layout item into account.</p>
<ol>
<li><p>Import some utilities from <code>jimu-layouts</code> and <code>jimu-layouts/layout-runtime</code>:</p>
<pre><code>import { React, ReactRedux, classNames, LayoutItemType } from &#39;jimu-core&#39;;
import { styleUtils } from &#39;jimu-ui&#39;;
import {
mapStateToLayoutItemProps,
LayoutItemProps,
StateToLayoutItemProps,
} from &#39;jimu-layouts/common&#39;;
import {
WidgetRenderer,
SectionRenderer,
} from &#39;jimu-layouts/layout-runtime&#39;;</code></pre></li>
<li><p>Create a React component, set props type to be <code>LayoutProps &amp; StateToLayoutProps</code>. If you need more properties, you can add them as needed.
<code>`</code>
class RowItem extends React.PureComponent&lt;LayoutItemProps &amp; StateToLayoutItemProps &amp; OwnProps&gt; {</p>
</li>
</ol>
<p>}
export default ReactRedux.connect&lt;StateToLayoutItemProps, {}, LayoutItemProps &amp; OwnProps&gt;(
  mapStateToLayoutItemProps,
)(RowItem);</p>
<pre><code>
3. Implement the `render()` method.
You can access the `layoutItem` from the `props` of the component. The `layoutItem` property here refers to a layout item in the configuration.</code></pre><p>export interface LayoutItemJson {
  id?: string;
  bbox?: BoundingBox;
  type?: LayoutItemType;
  setting?: any;
  widgetId?: string;
  sectionId?: string;
  isPlaceholder?: boolean;
  isPending?: boolean;
}</p>
<pre><code>
Then you need to render the actual content of the layout item, either a widget or a section.
</code></pre><p>render() {
  const {
    span,
    offset,
    layoutId,
    layoutItem,
    itemDisplaySetting,
    style,
    widgetName,
  } = this.props;
  if (!layoutItem) {
    return null;
  }
  let mergedStyle;
  let mergedClass;
  // generage className and style for this item.</p>
<p>  let LayoutItem: any;
  if (layoutItem.type === LayoutItemType.Widget) {
    LayoutItem = WidgetRenderer;
  } else if (layoutItem.type === LayoutItemType.Section) {
    LayoutItem = SectionRenderer;
  } else {
    return null;
  }</p>
<p>  return (
    &lt;LayoutItem
      style={mergedStyle}
      className={mergedClass}
      layoutId={layoutId}
      layoutItemId={layoutItem.id}
      itemDisplaySetting={itemDisplaySetting}
      isInSection={layoutItem.type === LayoutItemType.Section}
      onClick={this.props.onClick}
    /&gt;
  );
}</p>
<pre><code>
#### Layout
Layout component also needs `LayoutProps` and `StateToLayoutProps`.</code></pre><p>import {mapStateToLayoutProps, LayoutProps, StateToLayoutProps} from &#39;jimu-layouts&#39;;</p>
<p>class RowLayout extends React.PureComponent&lt;FlexboxLayoutProps &amp; StateToLayoutProps&gt; {</p>
<p>}</p>
<p>export default ReactRedux.connect&lt;StateToLayoutProps, {}, FlexboxLayoutProps&gt;(mapStateToLayoutProps)(RowLayout);</p>
<pre><code>
In the `render()` method of a layout, we need to extract its content and render each child in order.</code></pre><p>render() {
  const { layout, className, config } = this.props;</p>
<p>  this.rows = this.collectRowItems();</p>
<p>  const layoutStyle: any = config.style || {};</p>
<p>  const mergedStyle: any = {
    ...styleUtils.toCSSStyle(layoutStyle as any),
  };</p>
<p>  return (&lt;div className={classNames(&#39;layout d-flex flex-column align-items-stretch&#39;, className)} css={css<code>width: 100%;
    overflow: hidden;</code>} style={mergedStyle} data-layoutid={layout.id}&gt;
    {this.rows.map((itemIds, index) =&gt; this.createRow(itemIds, index))}
  </div>);
}</p>
<pre><code>
### Builder of the layout
#### Layout item
Besides rendering the widget or a section, a layout item in builder also needs to handle dragging, dropping, and resizing. So we provide another set of renderers for the builder.</code></pre><p>import {WidgetRendererForBuilder, SectionRendererForBuilder} from &#39;jimu-layouts/layout-builder&#39;;</p>
<pre><code>
Each renderer component provides the following props:</code></pre><p>export interface RndOptions {
  offset: number;
  span: number;
  order: number;
  alignItems?: string;
  children?: any;
  style?: any;
  onResizeStart: (id: string) =&gt; void;
  onResizing: (id: string, x: number, y: number, dw: number, dh: number) =&gt; void;
  onResizeEnd: (id: string, x: number, y: number, dw: number, dh: number, layoutItem: LayoutItemJson) =&gt; void;
  onDragStart: (id: string) =&gt; void;
  onDragging: (id: string, dx: number, dy: number, outOfBoundary: boolean) =&gt; void;
  onDragEnd: (id: string, dx: number, dy: number, outOfBoundary: boolean) =&gt; void;
}</p>
<pre><code>
You need to define the dragging and resizing methods to adjust the position and size of the layout item.</code></pre><p>render() {
    const { layout, itemDisplaySetting, widgetWrapper } = this.props;</p>
<pre><code>// step 1, construct style from the setting of the layout item. Omitted here

// step 2, choose render for the item
let LayoutItem: any;
if (layoutItem.type === LayoutItemType.Widget) {
  LayoutItem = WidgetRendererForBuilder;
} else if (layoutItem.type === LayoutItemType.Section) {
  LayoutItem = SectionRendererForBuilder;
} else {
  return null;
}
// step 3, compose the item
return (
  &lt;LayoutItem
    style={mergedStyle}
    forwardRef={this.forwardRef}
    layoutId={layoutId}
    layoutItemId={layoutItem.id}
    onResizeStart={this.onResizeStart}
    onResizing={this.onResizing}
    onResizeEnd={this.onResizeEnd}
    onDragStart={this.props.onDragStart}
    onDragging={this.props.onDragging}
    onDragEnd={this.props.onDragEnd}
    left={true}
    right={true}
    top={false}
    bottom={!isRowWidget}
    itemDisplaySetting={itemDisplaySetting}
    draggable={draggable}
    resizable={resizable}
    selectable={selectable}
    isInSection={layoutItem.type === LayoutItemType.Section}
    onClick={this.props.onClick}
    className={mergedClass}/&gt;
);</code></pre><p>  }</p>
<pre><code>
#### Layout
A layout in builder should implement an interface `DropHandlers` in order to accept the item being dragged from the widget list or another layout widget. Also, it needs to be wrapped with `withDrop` provided by `jimu-layouts/layout-builder`.</code></pre><p>interface DropHandlers {
  onDragEnter?: (draggingItem: WidgetItemInfo | LayoutInfo) =&gt; void;
  onDragOver?: (draggingItem: WidgetItemInfo | LayoutInfo,
    containerRect: ClientRect,
    itemRect: ClientRect) =&gt; void;
  onDragLeave?: (draggingItem: WidgetItemInfo | LayoutInfo) =&gt; void;
  onDrop?: (draggingItem: WidgetItemInfo | LayoutInfo,
    containerRect: ClientRect, itemRect: ClientRect) =&gt; void;
}</p>
<pre><code></code></pre><p>import { LayoutProps, StateToLayoutProps, DropHandlers, mapStateToLayoutProps } from &#39;jimu-layouts&#39;;
import {withDrop} from &#39;jimu-layouts/layout-builder&#39;;</p>
<p>class SingleRow extends React.PureComponent&lt;RowLayoutProps, State&gt; implements DropHandlers {</p>
<p>}</p>
<p>export const Row = withDrop<RowLayoutProps>()(SingleRow);</p>
<pre><code>
There are two types of dragging and dropping behavior in the builder:
1. Drag an item from the widget list and drop it in a layout widget.
2. Drag an existing widget from the page or other layout widget and drop it in the current layout widget.

Developers can use the first parameter of the methods in `DropHandlers` interface to check whether the dragging item is from widget list or another place.
</code></pre><p>import {getAppConfigAction} from &#39;jimu-for-builder&#39;;</p>
<p>onDrop(draggingItem: WidgetItemInfo | LayoutInfo,
  containerRect: ClientRect, itemRect: ClientRect) {</p>
<p>  const {layoutId, layout} = this.props;
  const appConfigAction = getAppConfigAction();
  const layoutInfo = {
    layoutId,
    layoutItemId: layout.id
  };
  let insertIndex = layout.content.length; // append to the layout</p>
<p>  if ((draggingItem as LayoutInfo).layoutId &amp;&amp; (draggingItem as LayoutInfo).layoutItemId) {
    // dragging an existing layout item
    appConfigAction.moveWidgetBetweenLayouts(draggingItem as LayoutInfo, layoutInfo).exec();
    appConfigAction.dndExistingWidgetToFlexbox(draggingItem as LayoutInfo, layoutInfo, {
      width: itemRect.width,
      height: itemRect.height
    }, insertIndex).exec();
  } else {
    // dragging a new item from widget list
    appConfigAction.dndItemFromBuilder(draggingItem as WidgetItemInfo, layoutInfo, containerRect, itemRect, insertIndex);
  }
  this.referenceId = null;
}</p>
<pre><code>
## Wrap layout widget in widget
1. Export your layout builder in `builder-support.tsx`.</code></pre><p>import RowLayoutBuilder from &#39;../layout/builder/layout&#39;;
export default { RowLayoutBuilder };</p>
<pre><code>
2. Use different layout in your widget&#39;s `render()` method.</code></pre><p>import RowLayout from &#39;../layout/runtime/layout&#39;;</p>
<p>render(){
  const {layoutId, id, intl, theme, builderSupportModules} = this.props;</p>
<p>  const LayoutComponent = !window.jimuConfig.isInBuilder
      ? RowLayout
      : builderSupportModules.widgetModules.RowLayoutBuilder;</p>
<p>  if (!LayoutComponent) {
    return &lt;div style={{display: &#39;flex&#39;, justifyContent: &#39;center&#39;, alignItems: &#39;center&#39;}}&gt;
      No layout component!
    </div>;
  }</p>
<p>  return <div className="widget-row-layout d-flex w-100 h-100">
    &lt;LayoutComponent layouts={layouts[DEFAULT_EMBED_LAYOUT_NAME]}
    config={this.props.config} {...otherProps}&gt;
      &lt;WidgetPlaceholder
        icon={IconImage}
        widgetId={id}
        style={{
          border: &#39;none&#39;,
          pointerEvents: &#39;none&#39;,
        }}
        message={intl.formatMessage({ id: &#39;tips&#39;, defaultMessage: defaultMessages.tips })}
      /&gt;
    </LayoutComponent>
  </div>;
}</p>
<pre><code>
3. Create a layout item setting file if necessary. The name must be `item-setting.tsx` and it must be placed in the setting folder of the widget. Its `props` contains three members.</code></pre><p>export default class FlexboxItemSetting extends React.PureComponent&lt;{
  layoutId: string;
  layoutItem: LayoutItemJson;
  formatMessage: (id: string) =&gt; string;
  onSettingChange: (layoutInfo: LayoutInfo, setting) =&gt; void;
  onPosChange: (layoutInfo: LayoutInfo, bbox: BoundingBox) =&gt; void;
}&gt; {</p>
<p>}
<code>`</code></p>
<p>If any of the setting or the position/size is changed, you can invoke <code>onSettingChange</code> or <code>onPosChange</code> to save the new values into the configuration file.</p>
