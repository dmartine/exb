System.register([], function(__WEBPACK_DYNAMIC_EXPORT__) {

	return {

		execute: function() {
			__WEBPACK_DYNAMIC_EXPORT__(
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./node_modules/@esri/telemetry/dist/telemetry.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@esri/telemetry/dist/telemetry.js":
/*!********************************************************!*\
  !*** ./node_modules/@esri/telemetry/dist/telemetry.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\nfunction request(options, callback) {\n  var req = new XMLHttpRequest(); //eslint-disable-line\n  req.addEventListener('load', function () {\n    callback(req.responseText);\n  });\n\n  req.open(options.method, options.url);\n\n  Object.keys(options.headers).forEach(function (header) {\n    req.setRequestHeader(header, options.headers[header]);\n  });\n\n  req.send(options.body);\n}\n\nvar Storage = {\n  storage: {},\n  memory: true,\n  get: function get(key) {\n    var stored = void 0;\n    try {\n      stored = window.localStorage && window.localStorage.getItem(key) || this.storage[key];\n    } catch (e) {\n      stored = this.storage[key];\n    }\n    if (stored) {\n      try {\n        return JSON.parse(stored);\n      } catch (e) {\n        return undefined;\n      }\n    } else {\n      return undefined;\n    }\n  },\n  set: function set(key, value) {\n    // handle Safari private mode (setItem is not allowed)\n    value = JSON.stringify(value);\n    try {\n      window.localStorage.setItem(key, value);\n    } catch (e) {\n      if (!this.memory) {\n        console.error('setting local storage failed, falling back to in-memory storage');\n        this.memory = true;\n      }\n      this.storage[key] = value;\n    }\n  },\n  delete: function _delete(key) {\n    try {\n      window.localStorage.removeItem(key);\n    } catch (e) {\n      if (!this.memory) {\n        console.error('setting local storage failed, falling back to in-memory storage');\n        this.memory = true;\n      }\n      delete this.storage[key];\n    }\n  }\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar COGNITO_KEY = 'TELEMETRY_COGNITO_CREDENTIALS';\nvar COGNITO_URL = 'https://cognito-identity.us-east-1.amazonaws.com/';\n\nfunction getCredentials(IdentityPoolId, callback) {\n  var cached = Storage.get(COGNITO_KEY);\n  if (cached && Date.now() / 1000 < cached.Expiration) return callback(cached);\n\n  authWithCognito(IdentityPoolId, function (credentials) {\n    Storage.set(COGNITO_KEY, credentials);\n    callback(credentials);\n  });\n}\n\nfunction authWithCognito(IdentityPoolId, callback) {\n  var options = _extends({}, defaults$$1);\n  options.headers['X-Amz-Target'] = 'AWSCognitoIdentityService.GetId';\n  options.body = JSON.stringify({ IdentityPoolId: IdentityPoolId });\n\n  request(options, function (response) {\n    requestCredentials(JSON.parse(response), callback);\n  });\n}\n\nfunction requestCredentials(json, callback) {\n  var options = _extends({}, defaults$$1);\n  options.headers['X-Amz-Target'] = 'AWSCognitoIdentityService.GetCredentialsForIdentity';\n  options.body = JSON.stringify({ IdentityId: json.IdentityId });\n\n  request(options, function (response) {\n    var json = JSON.parse(response);\n    callback(json.Credentials);\n  });\n}\n\nvar defaults$$1 = {\n  method: 'POST',\n  url: COGNITO_URL,\n  headers: {\n    'Content-type': 'application/x-amz-json-1.1'\n  }\n};\n\nvar SESSION_LENGTH = 30 * 60 * 1000;\nvar SESSION_KEY = 'TELEMETRY_SESSION';\nvar CLIENT_KEY = 'TELEMETRY_CLIENT_ID';\n\nfunction getUser() {\n  return {\n    session: getSession(),\n    id: getClientID()\n  };\n}\n\nfunction getSession() {\n  var newSession = void 0;\n  var session = Storage.get(SESSION_KEY);\n  if (!session || Date.now() > session.expiration) {\n    newSession = true;\n    session = generateNewSession();\n  }\n  session.expiration = Date.now() + SESSION_LENGTH;\n  Storage.set(SESSION_KEY, session);\n  if (newSession) session.new = true;\n  return session;\n}\n\nfunction getClientID() {\n  var id = Storage.get(CLIENT_KEY);\n  if (!id) {\n    id = generateNewClientID();\n    Storage.set(CLIENT_KEY, id);\n  }\n  return id;\n}\n\nfunction generateNewSession() {\n  return {\n    id: Math.floor((1 + Math.random()) * 0x100000000000).toString(16),\n    startTimestamp: new Date().toISOString()\n  };\n}\n\n/*\n\nCopyright 2016 Amazon.com, Inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nfunction generateNewClientID() {\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n}\n\nfunction s4() {\n  return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n}\n\n/*\n(c) 2009-2013 by Jeff Mott. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions, and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions, and the following disclaimer in the documentation or other materials provided with the distribution.\nNeither the name CryptoJS nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS,\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\nvar CryptoJS = function (h, s) {\n  var f = {},\n      g = f.lib = {},\n      q = function q() {},\n      m = g.Base = { extend: function extend(a) {\n      q.prototype = this;var c = new q();a && c.mixIn(a);c.hasOwnProperty('init') || (c.init = function () {\n        c.$super.init.apply(this, arguments);\n      });c.init.prototype = c;c.$super = this;return c;\n    }, create: function create() {\n      var a = this.extend();a.init.apply(a, arguments);return a;\n    }, init: function init() {}, mixIn: function mixIn(a) {\n      for (var c in a) {\n        a.hasOwnProperty(c) && (this[c] = a[c]);\n      }a.hasOwnProperty('toString') && (this.toString = a.toString);\n    }, clone: function clone() {\n      return this.init.prototype.extend(this);\n    } },\n      r = g.WordArray = m.extend({ init: function init(a, c) {\n      a = this.words = a || [];this.sigBytes = c != s ? c : 4 * a.length;\n    }, toString: function toString(a) {\n      return (a || k).stringify(this);\n    }, concat: function concat(a) {\n      var c = this.words,\n          d = a.words,\n          b = this.sigBytes;a = a.sigBytes;this.clamp();if (b % 4) for (var e = 0; e < a; e++) {\n        c[b + e >>> 2] |= (d[e >>> 2] >>> 24 - 8 * (e % 4) & 255) << 24 - 8 * ((b + e) % 4);\n      } else if (d.length > 65535) for (e = 0; e < a; e += 4) {\n        c[b + e >>> 2] = d[e >>> 2];\n      } else c.push.apply(c, d);this.sigBytes += a;return this;\n    }, clamp: function clamp() {\n      var a = this.words,\n          c = this.sigBytes;a[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4);a.length = h.ceil(c / 4);\n    }, clone: function clone() {\n      var a = m.clone.call(this);a.words = this.words.slice(0);return a;\n    }, random: function random(a) {\n      for (var c = [], d = 0; d < a; d += 4) {\n        c.push(4294967296 * h.random() | 0);\n      }return new r.init(c, a);\n    } }),\n      l = f.enc = {},\n      k = l.Hex = { stringify: function stringify(a) {\n      var c = a.words;a = a.sigBytes;for (var d = [], b = 0; b < a; b++) {\n        var e = c[b >>> 2] >>> 24 - 8 * (b % 4) & 255;d.push((e >>> 4).toString(16));d.push((e & 15).toString(16));\n      }return d.join('');\n    }, parse: function parse(a) {\n      for (var c = a.length, d = [], b = 0; b < c; b += 2) {\n        d[b >>> 3] |= parseInt(a.substr(b, 2), 16) << 24 - 4 * (b % 8);\n      }return new r.init(d, c / 2);\n    } },\n      n = l.Latin1 = { stringify: function stringify(a) {\n      var c = a.words;a = a.sigBytes;for (var d = [], b = 0; b < a; b++) {\n        d.push(String.fromCharCode(c[b >>> 2] >>> 24 - 8 * (b % 4) & 255));\n      }return d.join('');\n    }, parse: function parse(a) {\n      for (var c = a.length, d = [], b = 0; b < c; b++) {\n        d[b >>> 2] |= (a.charCodeAt(b) & 255) << 24 - 8 * (b % 4);\n      }return new r.init(d, c);\n    } },\n      j = l.Utf8 = { stringify: function stringify(a) {\n      try {\n        return decodeURIComponent(escape(n.stringify(a)));\n      } catch (c) {\n        throw Error('Malformed UTF-8 data');\n      }\n    }, parse: function parse(a) {\n      return n.parse(unescape(encodeURIComponent(a)));\n    } },\n      u = g.BufferedBlockAlgorithm = m.extend({ reset: function reset() {\n      this._data = new r.init();this._nDataBytes = 0;\n    }, _append: function _append(a) {\n      typeof a === 'string' && (a = j.parse(a));this._data.concat(a);this._nDataBytes += a.sigBytes;\n    }, _process: function _process(a) {\n      var c = this._data,\n          d = c.words,\n          b = c.sigBytes,\n          e = this.blockSize,\n          f = b / (4 * e),\n          f = a ? h.ceil(f) : h.max((f | 0) - this._minBufferSize, 0);a = f * e;b = h.min(4 * a, b);if (a) {\n        for (var g = 0; g < a; g += e) {\n          this._doProcessBlock(d, g);\n        }g = d.splice(0, a);c.sigBytes -= b;\n      }return new r.init(g, b);\n    }, clone: function clone() {\n      var a = m.clone.call(this);\n      a._data = this._data.clone();return a;\n    }, _minBufferSize: 0 });g.Hasher = u.extend({ cfg: m.extend(), init: function init(a) {\n      this.cfg = this.cfg.extend(a);this.reset();\n    }, reset: function reset() {\n      u.reset.call(this);this._doReset();\n    }, update: function update(a) {\n      this._append(a);this._process();return this;\n    }, finalize: function finalize(a) {\n      a && this._append(a);return this._doFinalize();\n    }, blockSize: 16, _createHelper: function _createHelper(a) {\n      return function (c, d) {\n        return new a.init(d).finalize(c);\n      };\n    }, _createHmacHelper: function _createHmacHelper(a) {\n      return function (c, d) {\n        return new t.HMAC.init(a, d).finalize(c);\n      };\n    } });var t = f.algo = {};return f;\n}(Math);\n(function (h) {\n  for (var s = CryptoJS, f = s.lib, g = f.WordArray, q = f.Hasher, f = s.algo, m = [], r = [], l = function l(a) {\n    return 4294967296 * (a - (a | 0)) | 0;\n  }, k = 2, n = 0; n < 64;) {\n    var j;a: {\n      j = k;for (var u = h.sqrt(j), t = 2; t <= u; t++) {\n        if (!(j % t)) {\n          j = !1;break a;\n        }\n      }j = !0;\n    }j && (n < 8 && (m[n] = l(h.pow(k, 0.5))), r[n] = l(h.pow(k, 1 / 3)), n++);k++;\n  }var a = [],\n      f = f.SHA256 = q.extend({ _doReset: function _doReset() {\n      this._hash = new g.init(m.slice(0));\n    }, _doProcessBlock: function _doProcessBlock(c, d) {\n      for (var b = this._hash.words, e = b[0], f = b[1], g = b[2], j = b[3], h = b[4], m = b[5], n = b[6], q = b[7], p = 0; p < 64; p++) {\n        if (p < 16) {\n          a[p] = c[d + p] | 0;\n        } else {\n          var k = a[p - 15],\n              l = a[p - 2];a[p] = ((k << 25 | k >>> 7) ^ (k << 14 | k >>> 18) ^ k >>> 3) + a[p - 7] + ((l << 15 | l >>> 17) ^ (l << 13 | l >>> 19) ^ l >>> 10) + a[p - 16];\n        }k = q + ((h << 26 | h >>> 6) ^ (h << 21 | h >>> 11) ^ (h << 7 | h >>> 25)) + (h & m ^ ~h & n) + r[p] + a[p];l = ((e << 30 | e >>> 2) ^ (e << 19 | e >>> 13) ^ (e << 10 | e >>> 22)) + (e & f ^ e & g ^ f & g);q = n;n = m;m = h;h = j + k | 0;j = g;g = f;f = e;e = k + l | 0;\n      }b[0] = b[0] + e | 0;b[1] = b[1] + f | 0;b[2] = b[2] + g | 0;b[3] = b[3] + j | 0;b[4] = b[4] + h | 0;b[5] = b[5] + m | 0;b[6] = b[6] + n | 0;b[7] = b[7] + q | 0;\n    }, _doFinalize: function _doFinalize() {\n      var a = this._data,\n          d = a.words,\n          b = 8 * this._nDataBytes,\n          e = 8 * a.sigBytes;\n      d[e >>> 5] |= 128 << 24 - e % 32;d[(e + 64 >>> 9 << 4) + 14] = h.floor(b / 4294967296);d[(e + 64 >>> 9 << 4) + 15] = b;a.sigBytes = 4 * d.length;this._process();return this._hash;\n    }, clone: function clone() {\n      var a = q.clone.call(this);a._hash = this._hash.clone();return a;\n    } });s.SHA256 = q._createHelper(f);s.HmacSHA256 = q._createHmacHelper(f);\n})(Math);\n(function () {\n  var h = CryptoJS,\n      s = h.enc.Utf8;h.algo.HMAC = h.lib.Base.extend({ init: function init(f, g) {\n      f = this._hasher = new f.init();typeof g === 'string' && (g = s.parse(g));var h = f.blockSize,\n          m = 4 * h;g.sigBytes > m && (g = f.finalize(g));g.clamp();for (var r = this._oKey = g.clone(), l = this._iKey = g.clone(), k = r.words, n = l.words, j = 0; j < h; j++) {\n        k[j] ^= 1549556828, n[j] ^= 909522486;\n      }r.sigBytes = l.sigBytes = m;this.reset();\n    }, reset: function reset() {\n      var f = this._hasher;f.reset();f.update(this._iKey);\n    }, update: function update(f) {\n      this._hasher.update(f);return this;\n    }, finalize: function finalize(f) {\n      var g = this._hasher;f = g.finalize(f);g.reset();return g.finalize(this._oKey.clone().concat(f));\n    } });\n})();\n\n//\n// AWS Signature v4 Implementation for Web Browsers\n//\n// Copyright (c) 2016 Daniel Joos\n//\n// Distributed under MIT license. (See file LICENSE)\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\nvar defaultConfig = {\n  region: 'eu-west-1',\n  service: 'execute-api',\n  defaultContentType: 'application/json',\n  defaultAcceptType: 'application/json',\n  payloadSerializerFactory: JsonPayloadSerializer,\n  uriParserFactory: SimpleUriParser,\n  hasherFactory: CryptoJSHasher\n};\n\n/**\n * Create a new signer object with the given configuration.\n * Configuration must specify the AWS credentials used for the signing operation.\n * It must contain the following properties:\n * `accessKeyId`: The AWS IAM access key ID.\n * `secretAccessKey`: The AWS IAM secret key.\n * `sessionToken`: Optional session token, required for temporary credentials.\n * @param {object} config The configuration object.\n * @constructor\n */\n\nvar AwsSigner = function () {\n  function AwsSigner(config) {\n    classCallCheck(this, AwsSigner);\n\n    this.config = extend({}, defaultConfig, config);\n    this.payloadSerializer = this.config.payloadSerializer || this.config.payloadSerializerFactory();\n    this.uriParser = this.config.uriParserFactory();\n    this.hasher = this.config.hasherFactory();\n    assertRequired(this.config.accessKeyId, 'AwsSigner requires AWS AccessKeyID');\n    assertRequired(this.config.secretAccessKey, 'AwsSigner requires AWS SecretAccessKey');\n  }\n  /**\n   * Create signature headers for the given request.\n   * Request must be in the format, known from the `$http` service of Angular:\n   * ```\n   * request = {\n   *      headers: { ... },\n   *      method: 'GET',\n   *      url: 'http://...',\n   *      params: { ... },\n   *      data: ...           // alternative: body\n   * };\n   * ```\n   * The resulting object contains the signature headers. For example, it can be merged into an\n   * existing `$http` config when dealing with Angular JS.\n   * @param {object} request The request to create the signature for. Will not be modified!\n   * @param {Date=} signDate Optional signature date to use. Current date-time is used if not specified.\n   * @returns Signed request headers.\n   */\n\n\n  createClass(AwsSigner, [{\n    key: 'sign',\n    value: function sign(request, signDate) {\n      var workingSet = {\n        request: extend({}, request),\n        signDate: signDate || new Date(),\n        uri: this.uriParser(request.url)\n      };\n      prepare(this, workingSet);\n      buildCanonicalRequest(this, workingSet); // Step1: build the canonical request\n      buildStringToSign(this, workingSet); // Step2: build the string to sign\n      calculateSignature(this, workingSet); // Step3: calculate the signature hash\n      buildSignatureHeader(this, workingSet); // Step4: build the authorization header\n      return {\n        'Accept': workingSet.request.headers['accept'],\n        'Authorization': workingSet.authorization,\n        'Content-Type': workingSet.request.headers['content-type'],\n        'x-amz-date': workingSet.request.headers['x-amz-date'],\n        'x-amz-security-token': this.config.sessionToken || undefined\n      };\n    }\n  }]);\n  return AwsSigner;\n}();\n\n\n\n// Some preparations\nfunction prepare(self, ws) {\n  var headers = {\n    'host': ws.uri.host,\n    'content-type': self.config.defaultContentType,\n    'accept': self.config.defaultAcceptType,\n    'x-amz-date': amzDate(ws.signDate)\n  };\n  // Payload or not?\n  ws.request.method = ws.request.method.toUpperCase();\n  if (ws.request.body) {\n    ws.payload = ws.request.body;\n  } else if (ws.request.data && self.payloadSerializer) {\n    ws.payload = self.payloadSerializer(ws.request.data);\n  } else {\n    delete headers['content-type'];\n  }\n  // Headers\n  ws.request.headers = extend(headers, Object.keys(ws.request.headers || {}).reduce(function (normalized, key) {\n    normalized[key.toLowerCase()] = ws.request.headers[key];\n    return normalized;\n  }, {}));\n  ws.sortedHeaderKeys = Object.keys(ws.request.headers).sort();\n  // Remove content-type parameters as some browser might change them on send\n  if (ws.request.headers['content-type']) {\n    ws.request.headers['content-type'] = ws.request.headers['content-type'].split(';')[0];\n  }\n  // Merge params to query params\n  if (_typeof(ws.request.params) === 'object') {\n    extend(ws.uri.queryParams, ws.request.params);\n  }\n}\n\n// Convert the request to a canonical format.\nfunction buildCanonicalRequest(self, ws) {\n  ws.signedHeaders = ws.sortedHeaderKeys.map(function (key) {\n    return key.toLowerCase();\n  }).join(';');\n  ws.canonicalRequest = String(ws.request.method).toUpperCase() + '\\n' +\n  // Canonical URI:\n  encodeURI(ws.uri.path) + '\\n' +\n  // Canonical Query String:\n  Object.keys(ws.uri.queryParams).sort().map(function (key) {\n    return encodeURIComponent(key) + '=' + encodeURIComponent(ws.uri.queryParams[key]);\n  }).join('&') + '\\n' +\n  // Canonical Headers:\n  ws.sortedHeaderKeys.map(function (key) {\n    return key.toLocaleLowerCase() + ':' + ws.request.headers[key];\n  }).join('\\n') + '\\n\\n' +\n  // Signed Headers:\n  ws.signedHeaders + '\\n' +\n  // Hashed Payload\n  self.hasher.hash(ws.payload ? ws.payload : '');\n}\n\n// Construct the string that will be signed.\nfunction buildStringToSign(self, ws) {\n  ws.credentialScope = [amzDate(ws.signDate, true), self.config.region, self.config.service, 'aws4_request'].join('/');\n  ws.stringToSign = 'AWS4-HMAC-SHA256' + '\\n' + amzDate(ws.signDate) + '\\n' + ws.credentialScope + '\\n' + self.hasher.hash(ws.canonicalRequest);\n}\n\n// Calculate the signature\nfunction calculateSignature(self, ws) {\n  var hmac = self.hasher.hmac;\n  var signKey = hmac(hmac(hmac(hmac('AWS4' + self.config.secretAccessKey, amzDate(ws.signDate, true), { hexOutput: false }), self.config.region, { hexOutput: false, textInput: false }), self.config.service, { hexOutput: false, textInput: false }), 'aws4_request', { hexOutput: false, textInput: false });\n  ws.signature = hmac(signKey, ws.stringToSign, { textInput: false });\n}\n\n// Build the signature HTTP header using the data in the working set.\nfunction buildSignatureHeader(self, ws) {\n  ws.authorization = 'AWS4-HMAC-SHA256 ' + 'Credential=' + self.config.accessKeyId + '/' + ws.credentialScope + ', ' + 'SignedHeaders=' + ws.signedHeaders + ', ' + 'Signature=' + ws.signature;\n}\n\n// Format the given `Date` as AWS compliant date string.\n// Time part gets omitted if second argument is set to `true`.\nfunction amzDate(date, short) {\n  var result = date.toISOString().replace(/[:\\-]|\\.\\d{3}/g, '').substr(0, 17); // eslint-disable-line\n  if (short) {\n    return result.substr(0, 8);\n  }\n  return result;\n}\n\n/**\n * Payload serializer factory implementation that converts the data to a JSON string.\n */\nfunction JsonPayloadSerializer() {\n  return function (data) {\n    return JSON.stringify(data);\n  };\n}\n\n/**\n * Simple URI parser factory.\n * Uses an `a` document element for parsing given URIs.\n * Therefore it most likely will only work in a web browser.\n */\nfunction SimpleUriParser() {\n  var parser = document ? document.createElement('a') : {};\n\n  /**\n   * Parse the given URI.\n   * @param {string} uri The URI to parse.\n   * @returns JavaScript object with the parse results:\n   * `protocol`: The URI protocol part.\n   * `host`: Host part of the URI.\n   * `path`: Path part of the URI, always starting with a `/`\n   * `queryParams`: Query parameters as JavaScript object.\n   */\n  return function (uri) {\n    parser.href = uri;\n    return {\n      protocol: parser.protocol,\n      host: parser.host.replace(/^(.*):((80)|(443))$/, '$1'),\n      path: (parser.pathname.charAt(0) !== '/' ? '/' : '') + parser.pathname,\n      queryParams: extractQueryParams(parser.search)\n    };\n  };\n\n  function extractQueryParams(search) {\n    return (/^\\??(.*)$/.exec(search)[1].split('&').reduce(function (result, arg) {\n        arg = /^(.+)=(.*)$/.exec(arg);\n        if (arg) {\n          result[arg[1]] = arg[2];\n        }\n        return result;\n      }, {})\n    );\n  }\n}\n\n/**\n * Hash factory implementation using the SHA-256 hash algorithm of CryptoJS.\n * Requires at least the CryptoJS rollups: `sha256.js` and `hmac-sha256.js`.\n */\nfunction CryptoJSHasher() {\n  return {\n    /**\n     * Hash the given input using SHA-256 algorithm.\n     * The options can be used to control the in-/output of the hash operation.\n     * @param {*} input Input data.\n     * @param {object} options Options object:\n     * `hexOutput` -- Output the hash with hex encoding (default: `true`).\n     * `textInput` -- Interpret the input data as text (default: `true`).\n     * @returns The generated hash\n     */\n    hash: function hash(input, options) {\n      options = extend({ hexOutput: true, textInput: true }, options);\n      var hash = CryptoJS.SHA256(input);\n      if (options.hexOutput) {\n        return hash.toString(CryptoJS.enc.Hex);\n      }\n      return hash;\n    },\n\n    /**\n     * Create the HMAC of the given input data with the given key using the SHA-256\n     * hash algorithm.\n     * The options can be used to control the in-/output of the hash operation.\n     * @param {string} key Secret key.\n     * @param {*} input Input data.\n     * @param {object} options Options object:\n     * `hexOutput` -- Output the hash with hex encoding (default: `true`).\n     * `textInput` -- Interpret the input data as text (default: `true`).\n     * @returns The generated HMAC.\n     */\n    hmac: function hmac(key, input, options) {\n      options = extend({ hexOutput: true, textInput: true }, options);\n      var hmac = CryptoJS.HmacSHA256(input, key, { asBytes: true });\n      if (options.hexOutput) {\n        return hmac.toString(CryptoJS.enc.Hex);\n      }\n      return hmac;\n    }\n  };\n}\n\n// Simple version of the `extend` function, known from Angular and Backbone.\n// It merges the second (and all succeeding) argument(s) into the object, given as first\n// argument. This is done recursively for all child objects, as well.\nfunction extend(dest) {\n  var objs = [].slice.call(arguments, 1);\n  objs.forEach(function (obj) {\n    if (!obj || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n      return;\n    }\n    Object.keys(obj).forEach(function (key) {\n      var src = obj[key];\n      if (typeof src === 'undefined') {\n        return;\n      }\n      if (src !== null && (typeof src === 'undefined' ? 'undefined' : _typeof(src)) === 'object') {\n        dest[key] = Array.isArray(src) ? [] : {};\n        extend(dest[key], src);\n      } else {\n        dest[key] = src;\n      }\n    });\n  });\n  return dest;\n}\n\n// Throw an error if the given object is undefined.\nfunction assertRequired(obj, msg) {\n  if (typeof obj === 'undefined' || !obj) {\n    throw new Error(msg);\n  }\n}\n\nvar METRICS = ['size', 'duration', 'position', 'number', 'count'];\nvar DEFAULT_ENDPOINT = 'https://mobileanalytics.us-east-1.amazonaws.com/2014-06-05/events';\n\nvar Amazon = function () {\n  function Amazon(options) {\n    classCallCheck(this, Amazon);\n\n    this.name = 'amazon';\n    _extends(this, options);\n    var session = getUser().session;\n    if (session.new && !options.test) this.logEvent({ eventType: '_session.start' });\n  }\n\n  createClass(Amazon, [{\n    key: 'logPageView',\n    value: function logPageView(page, options) {\n      var event = createPageView(page, this.previousPage, options);\n      sendTelemetry(event, this.userPoolID, this.app);\n      this.previousPage = event.attributes;\n    }\n  }, {\n    key: 'logEvent',\n    value: function logEvent(event) {\n      var events = createEventLog(event);\n      sendTelemetry(events, this.userPoolID, this.app);\n    }\n  }]);\n  return Amazon;\n}();\n\nfunction createPageView(page) {\n  var previousPage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var session = getUser().session;\n  return {\n    eventType: 'pageView',\n    timestamp: new Date().toISOString(),\n    session: {\n      id: session.id,\n      startTimestamp: session.startTimestamp\n    },\n    attributes: _extends({\n      referrer: document.referrer,\n      hostname: window.location.hostname,\n      path: page || window.location.pathname,\n      pageUrl: page || window.location.pathname,\n      pageName: document.title,\n      previousPageUrl: previousPage.pageUrl,\n      previousPageName: previousPage.pageName\n    }, extractAttributes(options)),\n    metrics: extractMetrics(options)\n  };\n}\n\nfunction createEventLog(event) {\n  var session = getUser().session;\n  return {\n    eventType: event.eventType || 'other',\n    timestamp: new Date().toISOString(),\n    session: {\n      id: session.id,\n      startTimestamp: session.startTimestamp\n    },\n    attributes: _extends({\n      referrer: document.referrer,\n      hostname: window.location.hostname,\n      path: window.location.pathname\n    }, extractAttributes(event)),\n    metrics: extractMetrics(event)\n  };\n}\n\nfunction extractAttributes(event) {\n  var attributes = _extends({}, event);\n  delete attributes.workflow;\n  METRICS.forEach(function (metric) {\n    return delete attributes[metric];\n  });\n  Object.keys(attributes).forEach(function (attr) {\n    if (attr === 'json') {\n      attributes[attr] = attributes[attr] ? JSON.stringify(attributes[attr]) : 'null';\n    } else {\n      attributes[attr] = attributes[attr] !== undefined ? attributes[attr].toString() : 'null';\n    }\n  });\n  return attributes;\n}\n\nfunction extractMetrics(event) {\n  var metrics = {};\n  METRICS.forEach(function (metric) {\n    if (event[metric]) metrics[metric] = event[metric];\n  });\n  return metrics;\n}\n\nfunction createHeaders() {\n  var credentials = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var options = arguments[1];\n\n  var config = {\n    region: 'us-east-1',\n    service: 'mobileanalytics',\n    accessKeyId: credentials.AccessKeyId,\n    secretAccessKey: credentials.SecretKey,\n    sessionToken: credentials.SessionToken\n  };\n  var signer = new AwsSigner(config);\n  var signed = signer.sign(options);\n  return signed;\n}\n\nfunction createClientContext(clientId, app) {\n  // eslint-disable-line\n  return JSON.stringify({\n    client: {\n      client_id: clientId,\n      app_title: app.name,\n      app_version_name: app.version || 'unknown'\n    },\n    services: {\n      mobile_analytics: {\n        app_id: app.id\n      }\n    }\n  });\n}\n\nfunction sendTelemetry(events, userPoolID, app) {\n  var user = getUser();\n  events = Array.isArray(events) ? events : [events];\n  var options = createTelemetryOptions(events);\n  getCredentials(userPoolID, function (credentials) {\n    try {\n      options.headers = createHeaders(credentials, options);\n      options.headers['x-amz-Client-Context'] = createClientContext(user.id, app);\n    } catch (e) {\n      console.error(e);\n      return;\n    }\n    request(options, function (response) {\n      if (response) {\n        console.error(JSON.parse(response));\n      }\n    });\n  });\n}\n\nfunction createTelemetryOptions(events) {\n  var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ENDPOINT;\n\n  return {\n    url: url,\n    method: 'POST',\n    body: JSON.stringify({\n      events: events\n    })\n  };\n}\n\nvar Google = function () {\n  function Google() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, Google);\n\n    this.name = 'google';\n    _extends(this, options);\n  }\n\n  createClass(Google, [{\n    key: 'logPageView',\n    value: function logPageView(page, options) {\n      var pageviewObj = buildPageViewObject(page, options, this.dimensions, this.metrics);\n      getTrackers(function (trackers) {\n        trackers.forEach(function (tracker) {\n          tracker.send(pageviewObj);\n        });\n      });\n    }\n  }, {\n    key: 'logEvent',\n    value: function logEvent(event) {\n      var eventObject = buildEventObject(event, this.dimensions, this.metrics);\n      getTrackers(function (trackers) {\n        trackers.forEach(function (tracker) {\n          tracker.send(eventObject);\n        });\n      });\n    }\n  }]);\n  return Google;\n}();\n\nfunction getTrackers(callback) {\n  if (window.ga) {\n    window.ga(function () {\n      callback(window.ga.getAll());\n    });\n  } else {\n    console.log(new Error('Google Analytics trackers not available'));\n  }\n}\n\nfunction buildPageViewObject(page, options) {\n  var dimensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var metrics = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var pageviewObject = {\n    hitType: 'pageview',\n    page: page || window.location.pathname\n  };\n\n  return mapMetricsAndDimensions(pageviewObject, options, dimensions, metrics);\n}\n\nfunction buildEventObject(event) {\n  var dimensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var metrics = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var eventObject = {\n    hitType: 'event',\n    eventCategory: event.category || 'none',\n    eventAction: event.action,\n    eventLabel: event.label,\n    nonInteraction: event.nonInteraction\n  };\n\n  return mapMetricsAndDimensions(eventObject, event, dimensions, metrics);\n}\n\nfunction mapMetricsAndDimensions(inputObject, options, dimensions, metrics) {\n  var mappedObject = inputObject;\n\n  Object.keys(dimensions).forEach(function (dimension) {\n    mappedObject['dimension' + dimensions[dimension]] = options[dimension];\n  });\n\n  Object.keys(metrics).forEach(function (metric) {\n    mappedObject['metric' + metrics[metric]] = options[metric];\n  });\n\n  return mappedObject;\n}\n\nvar anonymize = function (user) {\n  if (!user) return undefined;\n  return CryptoJS.SHA256(user).toString(CryptoJS.enc.Hex);\n};\n\nvar internalOrgs = ['esri.com', 'esriuk.com', 'esri.de', 'esri.ca', 'esrifrance.fr', 'esri.nl', 'esri-portugal.pt', 'esribulgaria.com', 'esri.fi', 'esri.kr', 'esrimalaysia.com.my', 'esri.es', 'esriaustralia.com.au', 'esri-southafrica.com', 'esri.cl', 'esrichina.com.cn', 'esri.co', 'esriturkey.com.tr', 'geodata.no', 'esriitalia.it', 'esri.pl'];\n\n/*\n * Determines whether or not the telemetry library should be enabled based on passed in options\n */\nvar telemetryEnabled = function () {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var portal = options.portal || {};\n  if (options.disabled) {\n    // Tracking is manually disabled\n    return false;\n  } else if (navigator.doNotTrack === '1' || window.doNotTrack === '1') {\n    // user's browser has turned off tracking\n    return false;\n  } else if (typeof portal.eueiEnabled !== 'undefined' && portal.eueiEnabled === false) {\n    // Portal does not allow tracking\n    return false;\n  } else if (portal.eueiEnabled && portal.user && portal.user.orgId === portal.id) {\n    // Portal allows tracking; except when user is anonymous or doesn't belong to portal's org\n    return true;\n  } else if (portal.user && !portal.user.orgId && portal.ipCntryCode === 'US') {\n    // Public user in the United States on a portal that allows tracking\n    return true;\n  } else if (!portal.user && portal.ipCntryCode === 'US') {\n    // Anonymous user in the United States on a portal that allows tracking\n    return true;\n  } else if (Object.keys(portal).length > 0) {\n    // Initialized with a Portal object but does not meet tracking conditions\n    return false;\n  } else {\n    // Default condition not initialized with a Portal-Self object\n    return true;\n  }\n};\n\nvar Telemetry = function () {\n  function Telemetry(options) {\n    classCallCheck(this, Telemetry);\n\n    // Make sure failure to init this library cannot have side-effects\n    try {\n      this.trackers = [];\n      this.workflows = {};\n      this.test = options.test;\n      this.debug = options.debug;\n\n      this.disabled = !telemetryEnabled(options);\n      if (this.disabled) console.log('Telemetry Disabled');\n\n      if (options.portal && options.portal.user) {\n        var subscriptionInfo = options.portal.subscriptionInfo || {};\n        this.setUser(options.portal.user, subscriptionInfo.type);\n      } else if (options.user) {\n        this.setUser(options.user);\n      }\n\n      if (!this.disabled) {\n        this._initTrackers(options);\n      }\n    } catch (e) {\n      console.error('Telemetry Disabled');\n      console.error(e);\n      this.disabled = true;\n    }\n  }\n\n  createClass(Telemetry, [{\n    key: '_initTrackers',\n    value: function _initTrackers(options) {\n      if (options.amazon) {\n        var amazon = new Amazon(options.amazon);\n        this.trackers.push(amazon);\n      }\n\n      if (options.google) {\n        var google = new Google(options.google);\n        this.trackers.push(google);\n      }\n      if (!this.trackers.length) console.error(new Error('No trackers configured'));\n    }\n  }, {\n    key: 'setUser',\n    value: function setUser() {\n      var user = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var orgType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Public';\n\n      user = typeof user === 'string' ? { username: user } : user;\n      this.user = user;\n      this.user.accountType = orgType;\n      var internalDomain = void 0;\n      if (user.email && user.email.split) {\n        var domain = user.email.split('@')[1];\n        internalDomain = internalOrgs.filter(function (org) {\n          return domain === org;\n        }).length > 0;\n      }\n\n      if (internalDomain || ['In House', 'Demo and Marketing'].indexOf(orgType) > -1) {\n        this.user.internalUser = true;\n      }\n    }\n  }, {\n    key: 'logPageView',\n    value: function logPageView(page) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var attributes = this.preProcess(options);\n      if (this.debug) console.log('Tracking page view', JSON.stringify(attributes));else if (this.test && !this.disabled) return attributes;\n\n      if (!this.trackers.length || this.disabled) {\n        if (!this.disabled) console.error(new Error('Page view was not logged because no trackers are configured.'));\n        return false;\n      } else {\n        this.trackers.forEach(function (tracker) {\n          try {\n            tracker.logPageView(page, attributes);\n          } catch (e) {\n            console.error(tracker.name + ' tracker failed to log page view.', e);\n          }\n        });\n        return true;\n      }\n    }\n  }, {\n    key: 'logEvent',\n    value: function logEvent() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var event = this.preProcess(options);\n\n      if (this.debug) console.log('Tracking event', JSON.stringify(event));else if (this.test) return event;\n\n      if (!this.trackers.length || this.disabled) {\n        if (!this.disabled) console.error(new Error('Event was not logged because no trackers are configured.'));\n        return false;\n      } else {\n        this.trackers.forEach(function (tracker) {\n          try {\n            tracker.logEvent(event);\n          } catch (e) {\n            console.error(tracker.name + ' tracker failed to log event', e);\n          }\n        });\n        return true;\n      }\n    }\n  }, {\n    key: 'logError',\n    value: function logError() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var event = _extends({ eventType: 'error' }, options);\n      this.logEvent(event);\n    }\n  }, {\n    key: 'startWorkflow',\n    value: function startWorkflow(name) {\n      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var workflow = {\n        name: name,\n        start: Date.now(),\n        steps: [],\n        workflowId: Math.floor((1 + Math.random()) * 0x100000000000).toString(16)\n      };\n      this._saveWorkflow(workflow);\n      var workflowObj = _extends({ name: name, step: 'start' }, attributes);\n      this._logWorkflow(workflowObj);\n      return workflow;\n    }\n  }, {\n    key: 'stepWorkflow',\n    value: function stepWorkflow(name, step) {\n      var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var details = typeof options === 'string' ? attributes : attributes.details;\n      var workflowObj = _extends({ name: name, step: step, details: details }, attributes);\n      this._logWorkflow(workflowObj);\n    }\n  }, {\n    key: 'endWorkflow',\n    value: function endWorkflow(name) {\n      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var workflowObj = _extends({ name: name, step: 'finish' }, attributes);\n      this._logWorkflow(workflowObj);\n    }\n  }, {\n    key: 'cancelWorkflow',\n    value: function cancelWorkflow(name) {\n      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var workflowObj = _extends({ name: name, step: 'cancel' }, attributes);\n      this._logWorkflow(workflowObj);\n    }\n  }, {\n    key: 'getWorkflow',\n    value: function getWorkflow(name) {\n      var workflow = Storage.get('TELEMETRY-WORKFLOW:' + name);\n      // do not let old workflows be returned\n      if (workflow) {\n        var workflowAge = Date.now() - workflow.start;\n        var timeout = 30 * 60 * 1000;\n        if (workflowAge < timeout) {\n          return workflow;\n        } else {\n          this._deleteWorkflow(workflow);\n        }\n      }\n    }\n  }, {\n    key: '_saveWorkflow',\n    value: function _saveWorkflow(workflow) {\n      Storage.set('TELEMETRY-WORKFLOW:' + workflow.name, workflow);\n    }\n  }, {\n    key: '_deleteWorkflow',\n    value: function _deleteWorkflow(workflow) {\n      Storage.delete('TELEMETRY-WORKFLOW:' + workflow.name);\n    }\n  }, {\n    key: '_logWorkflow',\n    value: function _logWorkflow() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      /*\n      const workflow = {\n        name: 'add layer to map',\n        step: 'start',\n        details: 'some details about the step'\n      }\n      */\n      options = this.preProcess(options);\n      var workflow = this.getWorkflow(options.name);\n      if (!workflow) {\n        this.startWorkflow(options.name);\n        workflow = this.getWorkflow(options.name);\n      }\n      workflow.steps.push(options.step);\n      workflow.duration = (Date.now() - workflow.start) / 1000;\n\n      if (['cancel', 'finish'].indexOf(options.step) > -1) {\n        this._deleteWorkflow(workflow);\n      } else {\n        this._saveWorkflow(workflow);\n      }\n\n      var track = _extends(options, {\n        eventType: 'workflow',\n        category: options.name,\n        action: options.step,\n        label: options.details,\n        duration: workflow.duration,\n        workflowId: workflow.workflowId\n      });\n\n      this.logEvent(track);\n    }\n  }, {\n    key: 'preProcess',\n    value: function preProcess() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var userOptions = {};\n      if (this.user) {\n        userOptions = {\n          user: anonymize(this.user.username),\n          org: anonymize(this.user.orgId),\n          lastLogin: this.user.lastLogin,\n          userSince: this.user.created,\n          internalUser: this.user.internalUser || false,\n          accountType: this.user.accountType\n        };\n      }\n\n      return _extends({}, options, userOptions);\n    }\n  }]);\n  return Telemetry;\n}();\n\nreturn Telemetry;\n\n})));\n//# sourceMappingURL=telemetry.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVzcmkvdGVsZW1ldHJ5L2Rpc3QvdGVsZW1ldHJ5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Blc3JpL3RlbGVtZXRyeS9kaXN0L3RlbGVtZXRyeS5qcz80ODY1Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCd0ZWxlbWV0cnknLCBmYWN0b3J5KSA6XG5cdChnbG9iYWwuVGVsZW1ldHJ5ID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiByZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTsgLy9lc2xpbnQtZGlzYWJsZS1saW5lXG4gIHJlcS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrKHJlcS5yZXNwb25zZVRleHQpO1xuICB9KTtcblxuICByZXEub3BlbihvcHRpb25zLm1ldGhvZCwgb3B0aW9ucy51cmwpO1xuXG4gIE9iamVjdC5rZXlzKG9wdGlvbnMuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCBvcHRpb25zLmhlYWRlcnNbaGVhZGVyXSk7XG4gIH0pO1xuXG4gIHJlcS5zZW5kKG9wdGlvbnMuYm9keSk7XG59XG5cbnZhciBTdG9yYWdlID0ge1xuICBzdG9yYWdlOiB7fSxcbiAgbWVtb3J5OiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICB2YXIgc3RvcmVkID0gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICBzdG9yZWQgPSB3aW5kb3cubG9jYWxTdG9yYWdlICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpIHx8IHRoaXMuc3RvcmFnZVtrZXldO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHN0b3JlZCA9IHRoaXMuc3RvcmFnZVtrZXldO1xuICAgIH1cbiAgICBpZiAoc3RvcmVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIC8vIGhhbmRsZSBTYWZhcmkgcHJpdmF0ZSBtb2RlIChzZXRJdGVtIGlzIG5vdCBhbGxvd2VkKVxuICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIHRyeSB7XG4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCF0aGlzLm1lbW9yeSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdzZXR0aW5nIGxvY2FsIHN0b3JhZ2UgZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gaW4tbWVtb3J5IHN0b3JhZ2UnKTtcbiAgICAgICAgdGhpcy5tZW1vcnkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5zdG9yYWdlW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIGRlbGV0ZTogZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgICB0cnkge1xuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCF0aGlzLm1lbW9yeSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdzZXR0aW5nIGxvY2FsIHN0b3JhZ2UgZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gaW4tbWVtb3J5IHN0b3JhZ2UnKTtcbiAgICAgICAgdGhpcy5tZW1vcnkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMuc3RvcmFnZVtrZXldO1xuICAgIH1cbiAgfVxufTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG5cblxuXG5cblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBDT0dOSVRPX0tFWSA9ICdURUxFTUVUUllfQ09HTklUT19DUkVERU5USUFMUyc7XG52YXIgQ09HTklUT19VUkwgPSAnaHR0cHM6Ly9jb2duaXRvLWlkZW50aXR5LnVzLWVhc3QtMS5hbWF6b25hd3MuY29tLyc7XG5cbmZ1bmN0aW9uIGdldENyZWRlbnRpYWxzKElkZW50aXR5UG9vbElkLCBjYWxsYmFjaykge1xuICB2YXIgY2FjaGVkID0gU3RvcmFnZS5nZXQoQ09HTklUT19LRVkpO1xuICBpZiAoY2FjaGVkICYmIERhdGUubm93KCkgLyAxMDAwIDwgY2FjaGVkLkV4cGlyYXRpb24pIHJldHVybiBjYWxsYmFjayhjYWNoZWQpO1xuXG4gIGF1dGhXaXRoQ29nbml0byhJZGVudGl0eVBvb2xJZCwgZnVuY3Rpb24gKGNyZWRlbnRpYWxzKSB7XG4gICAgU3RvcmFnZS5zZXQoQ09HTklUT19LRVksIGNyZWRlbnRpYWxzKTtcbiAgICBjYWxsYmFjayhjcmVkZW50aWFscyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhdXRoV2l0aENvZ25pdG8oSWRlbnRpdHlQb29sSWQsIGNhbGxiYWNrKSB7XG4gIHZhciBvcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRzJCQxKTtcbiAgb3B0aW9ucy5oZWFkZXJzWydYLUFtei1UYXJnZXQnXSA9ICdBV1NDb2duaXRvSWRlbnRpdHlTZXJ2aWNlLkdldElkJztcbiAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoeyBJZGVudGl0eVBvb2xJZDogSWRlbnRpdHlQb29sSWQgfSk7XG5cbiAgcmVxdWVzdChvcHRpb25zLCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICByZXF1ZXN0Q3JlZGVudGlhbHMoSlNPTi5wYXJzZShyZXNwb25zZSksIGNhbGxiYWNrKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RDcmVkZW50aWFscyhqc29uLCBjYWxsYmFjaykge1xuICB2YXIgb3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0cyQkMSk7XG4gIG9wdGlvbnMuaGVhZGVyc1snWC1BbXotVGFyZ2V0J10gPSAnQVdTQ29nbml0b0lkZW50aXR5U2VydmljZS5HZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5JztcbiAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoeyBJZGVudGl0eUlkOiBqc29uLklkZW50aXR5SWQgfSk7XG5cbiAgcmVxdWVzdChvcHRpb25zLCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICB2YXIganNvbiA9IEpTT04ucGFyc2UocmVzcG9uc2UpO1xuICAgIGNhbGxiYWNrKGpzb24uQ3JlZGVudGlhbHMpO1xuICB9KTtcbn1cblxudmFyIGRlZmF1bHRzJCQxID0ge1xuICBtZXRob2Q6ICdQT1NUJyxcbiAgdXJsOiBDT0dOSVRPX1VSTCxcbiAgaGVhZGVyczoge1xuICAgICdDb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24veC1hbXotanNvbi0xLjEnXG4gIH1cbn07XG5cbnZhciBTRVNTSU9OX0xFTkdUSCA9IDMwICogNjAgKiAxMDAwO1xudmFyIFNFU1NJT05fS0VZID0gJ1RFTEVNRVRSWV9TRVNTSU9OJztcbnZhciBDTElFTlRfS0VZID0gJ1RFTEVNRVRSWV9DTElFTlRfSUQnO1xuXG5mdW5jdGlvbiBnZXRVc2VyKCkge1xuICByZXR1cm4ge1xuICAgIHNlc3Npb246IGdldFNlc3Npb24oKSxcbiAgICBpZDogZ2V0Q2xpZW50SUQoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTZXNzaW9uKCkge1xuICB2YXIgbmV3U2Vzc2lvbiA9IHZvaWQgMDtcbiAgdmFyIHNlc3Npb24gPSBTdG9yYWdlLmdldChTRVNTSU9OX0tFWSk7XG4gIGlmICghc2Vzc2lvbiB8fCBEYXRlLm5vdygpID4gc2Vzc2lvbi5leHBpcmF0aW9uKSB7XG4gICAgbmV3U2Vzc2lvbiA9IHRydWU7XG4gICAgc2Vzc2lvbiA9IGdlbmVyYXRlTmV3U2Vzc2lvbigpO1xuICB9XG4gIHNlc3Npb24uZXhwaXJhdGlvbiA9IERhdGUubm93KCkgKyBTRVNTSU9OX0xFTkdUSDtcbiAgU3RvcmFnZS5zZXQoU0VTU0lPTl9LRVksIHNlc3Npb24pO1xuICBpZiAobmV3U2Vzc2lvbikgc2Vzc2lvbi5uZXcgPSB0cnVlO1xuICByZXR1cm4gc2Vzc2lvbjtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50SUQoKSB7XG4gIHZhciBpZCA9IFN0b3JhZ2UuZ2V0KENMSUVOVF9LRVkpO1xuICBpZiAoIWlkKSB7XG4gICAgaWQgPSBnZW5lcmF0ZU5ld0NsaWVudElEKCk7XG4gICAgU3RvcmFnZS5zZXQoQ0xJRU5UX0tFWSwgaWQpO1xuICB9XG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVOZXdTZXNzaW9uKCkge1xuICByZXR1cm4ge1xuICAgIGlkOiBNYXRoLmZsb29yKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwMDAwMDAwMCkudG9TdHJpbmcoMTYpLFxuICAgIHN0YXJ0VGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgfTtcbn1cblxuLypcblxuQ29weXJpZ2h0IDIwMTYgQW1hem9uLmNvbSwgSW5jLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5mdW5jdGlvbiBnZW5lcmF0ZU5ld0NsaWVudElEKCkge1xuICByZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG59XG5cbmZ1bmN0aW9uIHM0KCkge1xuICByZXR1cm4gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKTtcbn1cblxuLypcbihjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cblJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMsIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5SZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zLCBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIG9yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5OZWl0aGVyIHRoZSBuYW1lIENyeXB0b0pTIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVMsXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSwgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG52YXIgQ3J5cHRvSlMgPSBmdW5jdGlvbiAoaCwgcykge1xuICB2YXIgZiA9IHt9LFxuICAgICAgZyA9IGYubGliID0ge30sXG4gICAgICBxID0gZnVuY3Rpb24gcSgpIHt9LFxuICAgICAgbSA9IGcuQmFzZSA9IHsgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoYSkge1xuICAgICAgcS5wcm90b3R5cGUgPSB0aGlzO3ZhciBjID0gbmV3IHEoKTthICYmIGMubWl4SW4oYSk7Yy5oYXNPd25Qcm9wZXJ0eSgnaW5pdCcpIHx8IChjLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGMuJHN1cGVyLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO2MuaW5pdC5wcm90b3R5cGUgPSBjO2MuJHN1cGVyID0gdGhpcztyZXR1cm4gYztcbiAgICB9LCBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHZhciBhID0gdGhpcy5leHRlbmQoKTthLmluaXQuYXBwbHkoYSwgYXJndW1lbnRzKTtyZXR1cm4gYTtcbiAgICB9LCBpbml0OiBmdW5jdGlvbiBpbml0KCkge30sIG1peEluOiBmdW5jdGlvbiBtaXhJbihhKSB7XG4gICAgICBmb3IgKHZhciBjIGluIGEpIHtcbiAgICAgICAgYS5oYXNPd25Qcm9wZXJ0eShjKSAmJiAodGhpc1tjXSA9IGFbY10pO1xuICAgICAgfWEuaGFzT3duUHJvcGVydHkoJ3RvU3RyaW5nJykgJiYgKHRoaXMudG9TdHJpbmcgPSBhLnRvU3RyaW5nKTtcbiAgICB9LCBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0LnByb3RvdHlwZS5leHRlbmQodGhpcyk7XG4gICAgfSB9LFxuICAgICAgciA9IGcuV29yZEFycmF5ID0gbS5leHRlbmQoeyBpbml0OiBmdW5jdGlvbiBpbml0KGEsIGMpIHtcbiAgICAgIGEgPSB0aGlzLndvcmRzID0gYSB8fCBbXTt0aGlzLnNpZ0J5dGVzID0gYyAhPSBzID8gYyA6IDQgKiBhLmxlbmd0aDtcbiAgICB9LCB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoYSkge1xuICAgICAgcmV0dXJuIChhIHx8IGspLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9LCBjb25jYXQ6IGZ1bmN0aW9uIGNvbmNhdChhKSB7XG4gICAgICB2YXIgYyA9IHRoaXMud29yZHMsXG4gICAgICAgICAgZCA9IGEud29yZHMsXG4gICAgICAgICAgYiA9IHRoaXMuc2lnQnl0ZXM7YSA9IGEuc2lnQnl0ZXM7dGhpcy5jbGFtcCgpO2lmIChiICUgNCkgZm9yICh2YXIgZSA9IDA7IGUgPCBhOyBlKyspIHtcbiAgICAgICAgY1tiICsgZSA+Pj4gMl0gfD0gKGRbZSA+Pj4gMl0gPj4+IDI0IC0gOCAqIChlICUgNCkgJiAyNTUpIDw8IDI0IC0gOCAqICgoYiArIGUpICUgNCk7XG4gICAgICB9IGVsc2UgaWYgKGQubGVuZ3RoID4gNjU1MzUpIGZvciAoZSA9IDA7IGUgPCBhOyBlICs9IDQpIHtcbiAgICAgICAgY1tiICsgZSA+Pj4gMl0gPSBkW2UgPj4+IDJdO1xuICAgICAgfSBlbHNlIGMucHVzaC5hcHBseShjLCBkKTt0aGlzLnNpZ0J5dGVzICs9IGE7cmV0dXJuIHRoaXM7XG4gICAgfSwgY2xhbXA6IGZ1bmN0aW9uIGNsYW1wKCkge1xuICAgICAgdmFyIGEgPSB0aGlzLndvcmRzLFxuICAgICAgICAgIGMgPSB0aGlzLnNpZ0J5dGVzO2FbYyA+Pj4gMl0gJj0gNDI5NDk2NzI5NSA8PCAzMiAtIDggKiAoYyAlIDQpO2EubGVuZ3RoID0gaC5jZWlsKGMgLyA0KTtcbiAgICB9LCBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICB2YXIgYSA9IG0uY2xvbmUuY2FsbCh0aGlzKTthLndvcmRzID0gdGhpcy53b3Jkcy5zbGljZSgwKTtyZXR1cm4gYTtcbiAgICB9LCByYW5kb206IGZ1bmN0aW9uIHJhbmRvbShhKSB7XG4gICAgICBmb3IgKHZhciBjID0gW10sIGQgPSAwOyBkIDwgYTsgZCArPSA0KSB7XG4gICAgICAgIGMucHVzaCg0Mjk0OTY3Mjk2ICogaC5yYW5kb20oKSB8IDApO1xuICAgICAgfXJldHVybiBuZXcgci5pbml0KGMsIGEpO1xuICAgIH0gfSksXG4gICAgICBsID0gZi5lbmMgPSB7fSxcbiAgICAgIGsgPSBsLkhleCA9IHsgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoYSkge1xuICAgICAgdmFyIGMgPSBhLndvcmRzO2EgPSBhLnNpZ0J5dGVzO2ZvciAodmFyIGQgPSBbXSwgYiA9IDA7IGIgPCBhOyBiKyspIHtcbiAgICAgICAgdmFyIGUgPSBjW2IgPj4+IDJdID4+PiAyNCAtIDggKiAoYiAlIDQpICYgMjU1O2QucHVzaCgoZSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtkLnB1c2goKGUgJiAxNSkudG9TdHJpbmcoMTYpKTtcbiAgICAgIH1yZXR1cm4gZC5qb2luKCcnKTtcbiAgICB9LCBwYXJzZTogZnVuY3Rpb24gcGFyc2UoYSkge1xuICAgICAgZm9yICh2YXIgYyA9IGEubGVuZ3RoLCBkID0gW10sIGIgPSAwOyBiIDwgYzsgYiArPSAyKSB7XG4gICAgICAgIGRbYiA+Pj4gM10gfD0gcGFyc2VJbnQoYS5zdWJzdHIoYiwgMiksIDE2KSA8PCAyNCAtIDQgKiAoYiAlIDgpO1xuICAgICAgfXJldHVybiBuZXcgci5pbml0KGQsIGMgLyAyKTtcbiAgICB9IH0sXG4gICAgICBuID0gbC5MYXRpbjEgPSB7IHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGEpIHtcbiAgICAgIHZhciBjID0gYS53b3JkczthID0gYS5zaWdCeXRlcztmb3IgKHZhciBkID0gW10sIGIgPSAwOyBiIDwgYTsgYisrKSB7XG4gICAgICAgIGQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNbYiA+Pj4gMl0gPj4+IDI0IC0gOCAqIChiICUgNCkgJiAyNTUpKTtcbiAgICAgIH1yZXR1cm4gZC5qb2luKCcnKTtcbiAgICB9LCBwYXJzZTogZnVuY3Rpb24gcGFyc2UoYSkge1xuICAgICAgZm9yICh2YXIgYyA9IGEubGVuZ3RoLCBkID0gW10sIGIgPSAwOyBiIDwgYzsgYisrKSB7XG4gICAgICAgIGRbYiA+Pj4gMl0gfD0gKGEuY2hhckNvZGVBdChiKSAmIDI1NSkgPDwgMjQgLSA4ICogKGIgJSA0KTtcbiAgICAgIH1yZXR1cm4gbmV3IHIuaW5pdChkLCBjKTtcbiAgICB9IH0sXG4gICAgICBqID0gbC5VdGY4ID0geyBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShhKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShuLnN0cmluZ2lmeShhKSkpO1xuICAgICAgfSBjYXRjaCAoYykge1xuICAgICAgICB0aHJvdyBFcnJvcignTWFsZm9ybWVkIFVURi04IGRhdGEnKTtcbiAgICAgIH1cbiAgICB9LCBwYXJzZTogZnVuY3Rpb24gcGFyc2UoYSkge1xuICAgICAgcmV0dXJuIG4ucGFyc2UodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGEpKSk7XG4gICAgfSB9LFxuICAgICAgdSA9IGcuQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IG0uZXh0ZW5kKHsgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5fZGF0YSA9IG5ldyByLmluaXQoKTt0aGlzLl9uRGF0YUJ5dGVzID0gMDtcbiAgICB9LCBfYXBwZW5kOiBmdW5jdGlvbiBfYXBwZW5kKGEpIHtcbiAgICAgIHR5cGVvZiBhID09PSAnc3RyaW5nJyAmJiAoYSA9IGoucGFyc2UoYSkpO3RoaXMuX2RhdGEuY29uY2F0KGEpO3RoaXMuX25EYXRhQnl0ZXMgKz0gYS5zaWdCeXRlcztcbiAgICB9LCBfcHJvY2VzczogZnVuY3Rpb24gX3Byb2Nlc3MoYSkge1xuICAgICAgdmFyIGMgPSB0aGlzLl9kYXRhLFxuICAgICAgICAgIGQgPSBjLndvcmRzLFxuICAgICAgICAgIGIgPSBjLnNpZ0J5dGVzLFxuICAgICAgICAgIGUgPSB0aGlzLmJsb2NrU2l6ZSxcbiAgICAgICAgICBmID0gYiAvICg0ICogZSksXG4gICAgICAgICAgZiA9IGEgPyBoLmNlaWwoZikgOiBoLm1heCgoZiB8IDApIC0gdGhpcy5fbWluQnVmZmVyU2l6ZSwgMCk7YSA9IGYgKiBlO2IgPSBoLm1pbig0ICogYSwgYik7aWYgKGEpIHtcbiAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCBhOyBnICs9IGUpIHtcbiAgICAgICAgICB0aGlzLl9kb1Byb2Nlc3NCbG9jayhkLCBnKTtcbiAgICAgICAgfWcgPSBkLnNwbGljZSgwLCBhKTtjLnNpZ0J5dGVzIC09IGI7XG4gICAgICB9cmV0dXJuIG5ldyByLmluaXQoZywgYik7XG4gICAgfSwgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgdmFyIGEgPSBtLmNsb25lLmNhbGwodGhpcyk7XG4gICAgICBhLl9kYXRhID0gdGhpcy5fZGF0YS5jbG9uZSgpO3JldHVybiBhO1xuICAgIH0sIF9taW5CdWZmZXJTaXplOiAwIH0pO2cuSGFzaGVyID0gdS5leHRlbmQoeyBjZmc6IG0uZXh0ZW5kKCksIGluaXQ6IGZ1bmN0aW9uIGluaXQoYSkge1xuICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoYSk7dGhpcy5yZXNldCgpO1xuICAgIH0sIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHUucmVzZXQuY2FsbCh0aGlzKTt0aGlzLl9kb1Jlc2V0KCk7XG4gICAgfSwgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoYSkge1xuICAgICAgdGhpcy5fYXBwZW5kKGEpO3RoaXMuX3Byb2Nlc3MoKTtyZXR1cm4gdGhpcztcbiAgICB9LCBmaW5hbGl6ZTogZnVuY3Rpb24gZmluYWxpemUoYSkge1xuICAgICAgYSAmJiB0aGlzLl9hcHBlbmQoYSk7cmV0dXJuIHRoaXMuX2RvRmluYWxpemUoKTtcbiAgICB9LCBibG9ja1NpemU6IDE2LCBfY3JlYXRlSGVscGVyOiBmdW5jdGlvbiBfY3JlYXRlSGVscGVyKGEpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYywgZCkge1xuICAgICAgICByZXR1cm4gbmV3IGEuaW5pdChkKS5maW5hbGl6ZShjKTtcbiAgICAgIH07XG4gICAgfSwgX2NyZWF0ZUhtYWNIZWxwZXI6IGZ1bmN0aW9uIF9jcmVhdGVIbWFjSGVscGVyKGEpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYywgZCkge1xuICAgICAgICByZXR1cm4gbmV3IHQuSE1BQy5pbml0KGEsIGQpLmZpbmFsaXplKGMpO1xuICAgICAgfTtcbiAgICB9IH0pO3ZhciB0ID0gZi5hbGdvID0ge307cmV0dXJuIGY7XG59KE1hdGgpO1xuKGZ1bmN0aW9uIChoKSB7XG4gIGZvciAodmFyIHMgPSBDcnlwdG9KUywgZiA9IHMubGliLCBnID0gZi5Xb3JkQXJyYXksIHEgPSBmLkhhc2hlciwgZiA9IHMuYWxnbywgbSA9IFtdLCByID0gW10sIGwgPSBmdW5jdGlvbiBsKGEpIHtcbiAgICByZXR1cm4gNDI5NDk2NzI5NiAqIChhIC0gKGEgfCAwKSkgfCAwO1xuICB9LCBrID0gMiwgbiA9IDA7IG4gPCA2NDspIHtcbiAgICB2YXIgajthOiB7XG4gICAgICBqID0gaztmb3IgKHZhciB1ID0gaC5zcXJ0KGopLCB0ID0gMjsgdCA8PSB1OyB0KyspIHtcbiAgICAgICAgaWYgKCEoaiAlIHQpKSB7XG4gICAgICAgICAgaiA9ICExO2JyZWFrIGE7XG4gICAgICAgIH1cbiAgICAgIH1qID0gITA7XG4gICAgfWogJiYgKG4gPCA4ICYmIChtW25dID0gbChoLnBvdyhrLCAwLjUpKSksIHJbbl0gPSBsKGgucG93KGssIDEgLyAzKSksIG4rKyk7aysrO1xuICB9dmFyIGEgPSBbXSxcbiAgICAgIGYgPSBmLlNIQTI1NiA9IHEuZXh0ZW5kKHsgX2RvUmVzZXQ6IGZ1bmN0aW9uIF9kb1Jlc2V0KCkge1xuICAgICAgdGhpcy5faGFzaCA9IG5ldyBnLmluaXQobS5zbGljZSgwKSk7XG4gICAgfSwgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiBfZG9Qcm9jZXNzQmxvY2soYywgZCkge1xuICAgICAgZm9yICh2YXIgYiA9IHRoaXMuX2hhc2gud29yZHMsIGUgPSBiWzBdLCBmID0gYlsxXSwgZyA9IGJbMl0sIGogPSBiWzNdLCBoID0gYls0XSwgbSA9IGJbNV0sIG4gPSBiWzZdLCBxID0gYls3XSwgcCA9IDA7IHAgPCA2NDsgcCsrKSB7XG4gICAgICAgIGlmIChwIDwgMTYpIHtcbiAgICAgICAgICBhW3BdID0gY1tkICsgcF0gfCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBrID0gYVtwIC0gMTVdLFxuICAgICAgICAgICAgICBsID0gYVtwIC0gMl07YVtwXSA9ICgoayA8PCAyNSB8IGsgPj4+IDcpIF4gKGsgPDwgMTQgfCBrID4+PiAxOCkgXiBrID4+PiAzKSArIGFbcCAtIDddICsgKChsIDw8IDE1IHwgbCA+Pj4gMTcpIF4gKGwgPDwgMTMgfCBsID4+PiAxOSkgXiBsID4+PiAxMCkgKyBhW3AgLSAxNl07XG4gICAgICAgIH1rID0gcSArICgoaCA8PCAyNiB8IGggPj4+IDYpIF4gKGggPDwgMjEgfCBoID4+PiAxMSkgXiAoaCA8PCA3IHwgaCA+Pj4gMjUpKSArIChoICYgbSBeIH5oICYgbikgKyByW3BdICsgYVtwXTtsID0gKChlIDw8IDMwIHwgZSA+Pj4gMikgXiAoZSA8PCAxOSB8IGUgPj4+IDEzKSBeIChlIDw8IDEwIHwgZSA+Pj4gMjIpKSArIChlICYgZiBeIGUgJiBnIF4gZiAmIGcpO3EgPSBuO24gPSBtO20gPSBoO2ggPSBqICsgayB8IDA7aiA9IGc7ZyA9IGY7ZiA9IGU7ZSA9IGsgKyBsIHwgMDtcbiAgICAgIH1iWzBdID0gYlswXSArIGUgfCAwO2JbMV0gPSBiWzFdICsgZiB8IDA7YlsyXSA9IGJbMl0gKyBnIHwgMDtiWzNdID0gYlszXSArIGogfCAwO2JbNF0gPSBiWzRdICsgaCB8IDA7Yls1XSA9IGJbNV0gKyBtIHwgMDtiWzZdID0gYls2XSArIG4gfCAwO2JbN10gPSBiWzddICsgcSB8IDA7XG4gICAgfSwgX2RvRmluYWxpemU6IGZ1bmN0aW9uIF9kb0ZpbmFsaXplKCkge1xuICAgICAgdmFyIGEgPSB0aGlzLl9kYXRhLFxuICAgICAgICAgIGQgPSBhLndvcmRzLFxuICAgICAgICAgIGIgPSA4ICogdGhpcy5fbkRhdGFCeXRlcyxcbiAgICAgICAgICBlID0gOCAqIGEuc2lnQnl0ZXM7XG4gICAgICBkW2UgPj4+IDVdIHw9IDEyOCA8PCAyNCAtIGUgJSAzMjtkWyhlICsgNjQgPj4+IDkgPDwgNCkgKyAxNF0gPSBoLmZsb29yKGIgLyA0Mjk0OTY3Mjk2KTtkWyhlICsgNjQgPj4+IDkgPDwgNCkgKyAxNV0gPSBiO2Euc2lnQnl0ZXMgPSA0ICogZC5sZW5ndGg7dGhpcy5fcHJvY2VzcygpO3JldHVybiB0aGlzLl9oYXNoO1xuICAgIH0sIGNsb25lOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHZhciBhID0gcS5jbG9uZS5jYWxsKHRoaXMpO2EuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7cmV0dXJuIGE7XG4gICAgfSB9KTtzLlNIQTI1NiA9IHEuX2NyZWF0ZUhlbHBlcihmKTtzLkhtYWNTSEEyNTYgPSBxLl9jcmVhdGVIbWFjSGVscGVyKGYpO1xufSkoTWF0aCk7XG4oZnVuY3Rpb24gKCkge1xuICB2YXIgaCA9IENyeXB0b0pTLFxuICAgICAgcyA9IGguZW5jLlV0Zjg7aC5hbGdvLkhNQUMgPSBoLmxpYi5CYXNlLmV4dGVuZCh7IGluaXQ6IGZ1bmN0aW9uIGluaXQoZiwgZykge1xuICAgICAgZiA9IHRoaXMuX2hhc2hlciA9IG5ldyBmLmluaXQoKTt0eXBlb2YgZyA9PT0gJ3N0cmluZycgJiYgKGcgPSBzLnBhcnNlKGcpKTt2YXIgaCA9IGYuYmxvY2tTaXplLFxuICAgICAgICAgIG0gPSA0ICogaDtnLnNpZ0J5dGVzID4gbSAmJiAoZyA9IGYuZmluYWxpemUoZykpO2cuY2xhbXAoKTtmb3IgKHZhciByID0gdGhpcy5fb0tleSA9IGcuY2xvbmUoKSwgbCA9IHRoaXMuX2lLZXkgPSBnLmNsb25lKCksIGsgPSByLndvcmRzLCBuID0gbC53b3JkcywgaiA9IDA7IGogPCBoOyBqKyspIHtcbiAgICAgICAga1tqXSBePSAxNTQ5NTU2ODI4LCBuW2pdIF49IDkwOTUyMjQ4NjtcbiAgICAgIH1yLnNpZ0J5dGVzID0gbC5zaWdCeXRlcyA9IG07dGhpcy5yZXNldCgpO1xuICAgIH0sIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHZhciBmID0gdGhpcy5faGFzaGVyO2YucmVzZXQoKTtmLnVwZGF0ZSh0aGlzLl9pS2V5KTtcbiAgICB9LCB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShmKSB7XG4gICAgICB0aGlzLl9oYXNoZXIudXBkYXRlKGYpO3JldHVybiB0aGlzO1xuICAgIH0sIGZpbmFsaXplOiBmdW5jdGlvbiBmaW5hbGl6ZShmKSB7XG4gICAgICB2YXIgZyA9IHRoaXMuX2hhc2hlcjtmID0gZy5maW5hbGl6ZShmKTtnLnJlc2V0KCk7cmV0dXJuIGcuZmluYWxpemUodGhpcy5fb0tleS5jbG9uZSgpLmNvbmNhdChmKSk7XG4gICAgfSB9KTtcbn0pKCk7XG5cbi8vXG4vLyBBV1MgU2lnbmF0dXJlIHY0IEltcGxlbWVudGF0aW9uIGZvciBXZWIgQnJvd3NlcnNcbi8vXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYgRGFuaWVsIEpvb3Ncbi8vXG4vLyBEaXN0cmlidXRlZCB1bmRlciBNSVQgbGljZW5zZS4gKFNlZSBmaWxlIExJQ0VOU0UpXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIFggQ09OU09SVElVTSBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vXG5cbnZhciBkZWZhdWx0Q29uZmlnID0ge1xuICByZWdpb246ICdldS13ZXN0LTEnLFxuICBzZXJ2aWNlOiAnZXhlY3V0ZS1hcGknLFxuICBkZWZhdWx0Q29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgZGVmYXVsdEFjY2VwdFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgcGF5bG9hZFNlcmlhbGl6ZXJGYWN0b3J5OiBKc29uUGF5bG9hZFNlcmlhbGl6ZXIsXG4gIHVyaVBhcnNlckZhY3Rvcnk6IFNpbXBsZVVyaVBhcnNlcixcbiAgaGFzaGVyRmFjdG9yeTogQ3J5cHRvSlNIYXNoZXJcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHNpZ25lciBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbi5cbiAqIENvbmZpZ3VyYXRpb24gbXVzdCBzcGVjaWZ5IHRoZSBBV1MgY3JlZGVudGlhbHMgdXNlZCBmb3IgdGhlIHNpZ25pbmcgb3BlcmF0aW9uLlxuICogSXQgbXVzdCBjb250YWluIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIGBhY2Nlc3NLZXlJZGA6IFRoZSBBV1MgSUFNIGFjY2VzcyBrZXkgSUQuXG4gKiBgc2VjcmV0QWNjZXNzS2V5YDogVGhlIEFXUyBJQU0gc2VjcmV0IGtleS5cbiAqIGBzZXNzaW9uVG9rZW5gOiBPcHRpb25hbCBzZXNzaW9uIHRva2VuLCByZXF1aXJlZCBmb3IgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzLlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG52YXIgQXdzU2lnbmVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBd3NTaWduZXIoY29uZmlnKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQXdzU2lnbmVyKTtcblxuICAgIHRoaXMuY29uZmlnID0gZXh0ZW5kKHt9LCBkZWZhdWx0Q29uZmlnLCBjb25maWcpO1xuICAgIHRoaXMucGF5bG9hZFNlcmlhbGl6ZXIgPSB0aGlzLmNvbmZpZy5wYXlsb2FkU2VyaWFsaXplciB8fCB0aGlzLmNvbmZpZy5wYXlsb2FkU2VyaWFsaXplckZhY3RvcnkoKTtcbiAgICB0aGlzLnVyaVBhcnNlciA9IHRoaXMuY29uZmlnLnVyaVBhcnNlckZhY3RvcnkoKTtcbiAgICB0aGlzLmhhc2hlciA9IHRoaXMuY29uZmlnLmhhc2hlckZhY3RvcnkoKTtcbiAgICBhc3NlcnRSZXF1aXJlZCh0aGlzLmNvbmZpZy5hY2Nlc3NLZXlJZCwgJ0F3c1NpZ25lciByZXF1aXJlcyBBV1MgQWNjZXNzS2V5SUQnKTtcbiAgICBhc3NlcnRSZXF1aXJlZCh0aGlzLmNvbmZpZy5zZWNyZXRBY2Nlc3NLZXksICdBd3NTaWduZXIgcmVxdWlyZXMgQVdTIFNlY3JldEFjY2Vzc0tleScpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgc2lnbmF0dXJlIGhlYWRlcnMgZm9yIHRoZSBnaXZlbiByZXF1ZXN0LlxuICAgKiBSZXF1ZXN0IG11c3QgYmUgaW4gdGhlIGZvcm1hdCwga25vd24gZnJvbSB0aGUgYCRodHRwYCBzZXJ2aWNlIG9mIEFuZ3VsYXI6XG4gICAqIGBgYFxuICAgKiByZXF1ZXN0ID0ge1xuICAgKiAgICAgIGhlYWRlcnM6IHsgLi4uIH0sXG4gICAqICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICogICAgICB1cmw6ICdodHRwOi8vLi4uJyxcbiAgICogICAgICBwYXJhbXM6IHsgLi4uIH0sXG4gICAqICAgICAgZGF0YTogLi4uICAgICAgICAgICAvLyBhbHRlcm5hdGl2ZTogYm9keVxuICAgKiB9O1xuICAgKiBgYGBcbiAgICogVGhlIHJlc3VsdGluZyBvYmplY3QgY29udGFpbnMgdGhlIHNpZ25hdHVyZSBoZWFkZXJzLiBGb3IgZXhhbXBsZSwgaXQgY2FuIGJlIG1lcmdlZCBpbnRvIGFuXG4gICAqIGV4aXN0aW5nIGAkaHR0cGAgY29uZmlnIHdoZW4gZGVhbGluZyB3aXRoIEFuZ3VsYXIgSlMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSByZXF1ZXN0IFRoZSByZXF1ZXN0IHRvIGNyZWF0ZSB0aGUgc2lnbmF0dXJlIGZvci4gV2lsbCBub3QgYmUgbW9kaWZpZWQhXG4gICAqIEBwYXJhbSB7RGF0ZT19IHNpZ25EYXRlIE9wdGlvbmFsIHNpZ25hdHVyZSBkYXRlIHRvIHVzZS4gQ3VycmVudCBkYXRlLXRpbWUgaXMgdXNlZCBpZiBub3Qgc3BlY2lmaWVkLlxuICAgKiBAcmV0dXJucyBTaWduZWQgcmVxdWVzdCBoZWFkZXJzLlxuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKEF3c1NpZ25lciwgW3tcbiAgICBrZXk6ICdzaWduJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2lnbihyZXF1ZXN0LCBzaWduRGF0ZSkge1xuICAgICAgdmFyIHdvcmtpbmdTZXQgPSB7XG4gICAgICAgIHJlcXVlc3Q6IGV4dGVuZCh7fSwgcmVxdWVzdCksXG4gICAgICAgIHNpZ25EYXRlOiBzaWduRGF0ZSB8fCBuZXcgRGF0ZSgpLFxuICAgICAgICB1cmk6IHRoaXMudXJpUGFyc2VyKHJlcXVlc3QudXJsKVxuICAgICAgfTtcbiAgICAgIHByZXBhcmUodGhpcywgd29ya2luZ1NldCk7XG4gICAgICBidWlsZENhbm9uaWNhbFJlcXVlc3QodGhpcywgd29ya2luZ1NldCk7IC8vIFN0ZXAxOiBidWlsZCB0aGUgY2Fub25pY2FsIHJlcXVlc3RcbiAgICAgIGJ1aWxkU3RyaW5nVG9TaWduKHRoaXMsIHdvcmtpbmdTZXQpOyAvLyBTdGVwMjogYnVpbGQgdGhlIHN0cmluZyB0byBzaWduXG4gICAgICBjYWxjdWxhdGVTaWduYXR1cmUodGhpcywgd29ya2luZ1NldCk7IC8vIFN0ZXAzOiBjYWxjdWxhdGUgdGhlIHNpZ25hdHVyZSBoYXNoXG4gICAgICBidWlsZFNpZ25hdHVyZUhlYWRlcih0aGlzLCB3b3JraW5nU2V0KTsgLy8gU3RlcDQ6IGJ1aWxkIHRoZSBhdXRob3JpemF0aW9uIGhlYWRlclxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ0FjY2VwdCc6IHdvcmtpbmdTZXQucmVxdWVzdC5oZWFkZXJzWydhY2NlcHQnXSxcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiB3b3JraW5nU2V0LmF1dGhvcml6YXRpb24sXG4gICAgICAgICdDb250ZW50LVR5cGUnOiB3b3JraW5nU2V0LnJlcXVlc3QuaGVhZGVyc1snY29udGVudC10eXBlJ10sXG4gICAgICAgICd4LWFtei1kYXRlJzogd29ya2luZ1NldC5yZXF1ZXN0LmhlYWRlcnNbJ3gtYW16LWRhdGUnXSxcbiAgICAgICAgJ3gtYW16LXNlY3VyaXR5LXRva2VuJzogdGhpcy5jb25maWcuc2Vzc2lvblRva2VuIHx8IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEF3c1NpZ25lcjtcbn0oKTtcblxuXG5cbi8vIFNvbWUgcHJlcGFyYXRpb25zXG5mdW5jdGlvbiBwcmVwYXJlKHNlbGYsIHdzKSB7XG4gIHZhciBoZWFkZXJzID0ge1xuICAgICdob3N0Jzogd3MudXJpLmhvc3QsXG4gICAgJ2NvbnRlbnQtdHlwZSc6IHNlbGYuY29uZmlnLmRlZmF1bHRDb250ZW50VHlwZSxcbiAgICAnYWNjZXB0Jzogc2VsZi5jb25maWcuZGVmYXVsdEFjY2VwdFR5cGUsXG4gICAgJ3gtYW16LWRhdGUnOiBhbXpEYXRlKHdzLnNpZ25EYXRlKVxuICB9O1xuICAvLyBQYXlsb2FkIG9yIG5vdD9cbiAgd3MucmVxdWVzdC5tZXRob2QgPSB3cy5yZXF1ZXN0Lm1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICBpZiAod3MucmVxdWVzdC5ib2R5KSB7XG4gICAgd3MucGF5bG9hZCA9IHdzLnJlcXVlc3QuYm9keTtcbiAgfSBlbHNlIGlmICh3cy5yZXF1ZXN0LmRhdGEgJiYgc2VsZi5wYXlsb2FkU2VyaWFsaXplcikge1xuICAgIHdzLnBheWxvYWQgPSBzZWxmLnBheWxvYWRTZXJpYWxpemVyKHdzLnJlcXVlc3QuZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICB9XG4gIC8vIEhlYWRlcnNcbiAgd3MucmVxdWVzdC5oZWFkZXJzID0gZXh0ZW5kKGhlYWRlcnMsIE9iamVjdC5rZXlzKHdzLnJlcXVlc3QuaGVhZGVycyB8fCB7fSkucmVkdWNlKGZ1bmN0aW9uIChub3JtYWxpemVkLCBrZXkpIHtcbiAgICBub3JtYWxpemVkW2tleS50b0xvd2VyQ2FzZSgpXSA9IHdzLnJlcXVlc3QuaGVhZGVyc1trZXldO1xuICAgIHJldHVybiBub3JtYWxpemVkO1xuICB9LCB7fSkpO1xuICB3cy5zb3J0ZWRIZWFkZXJLZXlzID0gT2JqZWN0LmtleXMod3MucmVxdWVzdC5oZWFkZXJzKS5zb3J0KCk7XG4gIC8vIFJlbW92ZSBjb250ZW50LXR5cGUgcGFyYW1ldGVycyBhcyBzb21lIGJyb3dzZXIgbWlnaHQgY2hhbmdlIHRoZW0gb24gc2VuZFxuICBpZiAod3MucmVxdWVzdC5oZWFkZXJzWydjb250ZW50LXR5cGUnXSkge1xuICAgIHdzLnJlcXVlc3QuaGVhZGVyc1snY29udGVudC10eXBlJ10gPSB3cy5yZXF1ZXN0LmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddLnNwbGl0KCc7JylbMF07XG4gIH1cbiAgLy8gTWVyZ2UgcGFyYW1zIHRvIHF1ZXJ5IHBhcmFtc1xuICBpZiAoX3R5cGVvZih3cy5yZXF1ZXN0LnBhcmFtcykgPT09ICdvYmplY3QnKSB7XG4gICAgZXh0ZW5kKHdzLnVyaS5xdWVyeVBhcmFtcywgd3MucmVxdWVzdC5wYXJhbXMpO1xuICB9XG59XG5cbi8vIENvbnZlcnQgdGhlIHJlcXVlc3QgdG8gYSBjYW5vbmljYWwgZm9ybWF0LlxuZnVuY3Rpb24gYnVpbGRDYW5vbmljYWxSZXF1ZXN0KHNlbGYsIHdzKSB7XG4gIHdzLnNpZ25lZEhlYWRlcnMgPSB3cy5zb3J0ZWRIZWFkZXJLZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpO1xuICB9KS5qb2luKCc7Jyk7XG4gIHdzLmNhbm9uaWNhbFJlcXVlc3QgPSBTdHJpbmcod3MucmVxdWVzdC5tZXRob2QpLnRvVXBwZXJDYXNlKCkgKyAnXFxuJyArXG4gIC8vIENhbm9uaWNhbCBVUkk6XG4gIGVuY29kZVVSSSh3cy51cmkucGF0aCkgKyAnXFxuJyArXG4gIC8vIENhbm9uaWNhbCBRdWVyeSBTdHJpbmc6XG4gIE9iamVjdC5rZXlzKHdzLnVyaS5xdWVyeVBhcmFtcykuc29ydCgpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHdzLnVyaS5xdWVyeVBhcmFtc1trZXldKTtcbiAgfSkuam9pbignJicpICsgJ1xcbicgK1xuICAvLyBDYW5vbmljYWwgSGVhZGVyczpcbiAgd3Muc29ydGVkSGVhZGVyS2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkudG9Mb2NhbGVMb3dlckNhc2UoKSArICc6JyArIHdzLnJlcXVlc3QuaGVhZGVyc1trZXldO1xuICB9KS5qb2luKCdcXG4nKSArICdcXG5cXG4nICtcbiAgLy8gU2lnbmVkIEhlYWRlcnM6XG4gIHdzLnNpZ25lZEhlYWRlcnMgKyAnXFxuJyArXG4gIC8vIEhhc2hlZCBQYXlsb2FkXG4gIHNlbGYuaGFzaGVyLmhhc2god3MucGF5bG9hZCA/IHdzLnBheWxvYWQgOiAnJyk7XG59XG5cbi8vIENvbnN0cnVjdCB0aGUgc3RyaW5nIHRoYXQgd2lsbCBiZSBzaWduZWQuXG5mdW5jdGlvbiBidWlsZFN0cmluZ1RvU2lnbihzZWxmLCB3cykge1xuICB3cy5jcmVkZW50aWFsU2NvcGUgPSBbYW16RGF0ZSh3cy5zaWduRGF0ZSwgdHJ1ZSksIHNlbGYuY29uZmlnLnJlZ2lvbiwgc2VsZi5jb25maWcuc2VydmljZSwgJ2F3czRfcmVxdWVzdCddLmpvaW4oJy8nKTtcbiAgd3Muc3RyaW5nVG9TaWduID0gJ0FXUzQtSE1BQy1TSEEyNTYnICsgJ1xcbicgKyBhbXpEYXRlKHdzLnNpZ25EYXRlKSArICdcXG4nICsgd3MuY3JlZGVudGlhbFNjb3BlICsgJ1xcbicgKyBzZWxmLmhhc2hlci5oYXNoKHdzLmNhbm9uaWNhbFJlcXVlc3QpO1xufVxuXG4vLyBDYWxjdWxhdGUgdGhlIHNpZ25hdHVyZVxuZnVuY3Rpb24gY2FsY3VsYXRlU2lnbmF0dXJlKHNlbGYsIHdzKSB7XG4gIHZhciBobWFjID0gc2VsZi5oYXNoZXIuaG1hYztcbiAgdmFyIHNpZ25LZXkgPSBobWFjKGhtYWMoaG1hYyhobWFjKCdBV1M0JyArIHNlbGYuY29uZmlnLnNlY3JldEFjY2Vzc0tleSwgYW16RGF0ZSh3cy5zaWduRGF0ZSwgdHJ1ZSksIHsgaGV4T3V0cHV0OiBmYWxzZSB9KSwgc2VsZi5jb25maWcucmVnaW9uLCB7IGhleE91dHB1dDogZmFsc2UsIHRleHRJbnB1dDogZmFsc2UgfSksIHNlbGYuY29uZmlnLnNlcnZpY2UsIHsgaGV4T3V0cHV0OiBmYWxzZSwgdGV4dElucHV0OiBmYWxzZSB9KSwgJ2F3czRfcmVxdWVzdCcsIHsgaGV4T3V0cHV0OiBmYWxzZSwgdGV4dElucHV0OiBmYWxzZSB9KTtcbiAgd3Muc2lnbmF0dXJlID0gaG1hYyhzaWduS2V5LCB3cy5zdHJpbmdUb1NpZ24sIHsgdGV4dElucHV0OiBmYWxzZSB9KTtcbn1cblxuLy8gQnVpbGQgdGhlIHNpZ25hdHVyZSBIVFRQIGhlYWRlciB1c2luZyB0aGUgZGF0YSBpbiB0aGUgd29ya2luZyBzZXQuXG5mdW5jdGlvbiBidWlsZFNpZ25hdHVyZUhlYWRlcihzZWxmLCB3cykge1xuICB3cy5hdXRob3JpemF0aW9uID0gJ0FXUzQtSE1BQy1TSEEyNTYgJyArICdDcmVkZW50aWFsPScgKyBzZWxmLmNvbmZpZy5hY2Nlc3NLZXlJZCArICcvJyArIHdzLmNyZWRlbnRpYWxTY29wZSArICcsICcgKyAnU2lnbmVkSGVhZGVycz0nICsgd3Muc2lnbmVkSGVhZGVycyArICcsICcgKyAnU2lnbmF0dXJlPScgKyB3cy5zaWduYXR1cmU7XG59XG5cbi8vIEZvcm1hdCB0aGUgZ2l2ZW4gYERhdGVgIGFzIEFXUyBjb21wbGlhbnQgZGF0ZSBzdHJpbmcuXG4vLyBUaW1lIHBhcnQgZ2V0cyBvbWl0dGVkIGlmIHNlY29uZCBhcmd1bWVudCBpcyBzZXQgdG8gYHRydWVgLlxuZnVuY3Rpb24gYW16RGF0ZShkYXRlLCBzaG9ydCkge1xuICB2YXIgcmVzdWx0ID0gZGF0ZS50b0lTT1N0cmluZygpLnJlcGxhY2UoL1s6XFwtXXxcXC5cXGR7M30vZywgJycpLnN1YnN0cigwLCAxNyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgaWYgKHNob3J0KSB7XG4gICAgcmV0dXJuIHJlc3VsdC5zdWJzdHIoMCwgOCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBQYXlsb2FkIHNlcmlhbGl6ZXIgZmFjdG9yeSBpbXBsZW1lbnRhdGlvbiB0aGF0IGNvbnZlcnRzIHRoZSBkYXRhIHRvIGEgSlNPTiBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIEpzb25QYXlsb2FkU2VyaWFsaXplcigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICB9O1xufVxuXG4vKipcbiAqIFNpbXBsZSBVUkkgcGFyc2VyIGZhY3RvcnkuXG4gKiBVc2VzIGFuIGBhYCBkb2N1bWVudCBlbGVtZW50IGZvciBwYXJzaW5nIGdpdmVuIFVSSXMuXG4gKiBUaGVyZWZvcmUgaXQgbW9zdCBsaWtlbHkgd2lsbCBvbmx5IHdvcmsgaW4gYSB3ZWIgYnJvd3Nlci5cbiAqL1xuZnVuY3Rpb24gU2ltcGxlVXJpUGFyc2VyKCkge1xuICB2YXIgcGFyc2VyID0gZG9jdW1lbnQgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJykgOiB7fTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIGdpdmVuIFVSSS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVyaSBUaGUgVVJJIHRvIHBhcnNlLlxuICAgKiBAcmV0dXJucyBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIHRoZSBwYXJzZSByZXN1bHRzOlxuICAgKiBgcHJvdG9jb2xgOiBUaGUgVVJJIHByb3RvY29sIHBhcnQuXG4gICAqIGBob3N0YDogSG9zdCBwYXJ0IG9mIHRoZSBVUkkuXG4gICAqIGBwYXRoYDogUGF0aCBwYXJ0IG9mIHRoZSBVUkksIGFsd2F5cyBzdGFydGluZyB3aXRoIGEgYC9gXG4gICAqIGBxdWVyeVBhcmFtc2A6IFF1ZXJ5IHBhcmFtZXRlcnMgYXMgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gKHVyaSkge1xuICAgIHBhcnNlci5ocmVmID0gdXJpO1xuICAgIHJldHVybiB7XG4gICAgICBwcm90b2NvbDogcGFyc2VyLnByb3RvY29sLFxuICAgICAgaG9zdDogcGFyc2VyLmhvc3QucmVwbGFjZSgvXiguKik6KCg4MCl8KDQ0MykpJC8sICckMScpLFxuICAgICAgcGF0aDogKHBhcnNlci5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJyA/ICcvJyA6ICcnKSArIHBhcnNlci5wYXRobmFtZSxcbiAgICAgIHF1ZXJ5UGFyYW1zOiBleHRyYWN0UXVlcnlQYXJhbXMocGFyc2VyLnNlYXJjaClcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGV4dHJhY3RRdWVyeVBhcmFtcyhzZWFyY2gpIHtcbiAgICByZXR1cm4gKC9eXFw/PyguKikkLy5leGVjKHNlYXJjaClbMV0uc3BsaXQoJyYnKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgYXJnKSB7XG4gICAgICAgIGFyZyA9IC9eKC4rKT0oLiopJC8uZXhlYyhhcmcpO1xuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgcmVzdWx0W2FyZ1sxXV0gPSBhcmdbMl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sIHt9KVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYXNoIGZhY3RvcnkgaW1wbGVtZW50YXRpb24gdXNpbmcgdGhlIFNIQS0yNTYgaGFzaCBhbGdvcml0aG0gb2YgQ3J5cHRvSlMuXG4gKiBSZXF1aXJlcyBhdCBsZWFzdCB0aGUgQ3J5cHRvSlMgcm9sbHVwczogYHNoYTI1Ni5qc2AgYW5kIGBobWFjLXNoYTI1Ni5qc2AuXG4gKi9cbmZ1bmN0aW9uIENyeXB0b0pTSGFzaGVyKCkge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEhhc2ggdGhlIGdpdmVuIGlucHV0IHVzaW5nIFNIQS0yNTYgYWxnb3JpdGhtLlxuICAgICAqIFRoZSBvcHRpb25zIGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIGluLS9vdXRwdXQgb2YgdGhlIGhhc2ggb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gaW5wdXQgSW5wdXQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdDpcbiAgICAgKiBgaGV4T3V0cHV0YCAtLSBPdXRwdXQgdGhlIGhhc2ggd2l0aCBoZXggZW5jb2RpbmcgKGRlZmF1bHQ6IGB0cnVlYCkuXG4gICAgICogYHRleHRJbnB1dGAgLS0gSW50ZXJwcmV0IHRoZSBpbnB1dCBkYXRhIGFzIHRleHQgKGRlZmF1bHQ6IGB0cnVlYCkuXG4gICAgICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBoYXNoXG4gICAgICovXG4gICAgaGFzaDogZnVuY3Rpb24gaGFzaChpbnB1dCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IGV4dGVuZCh7IGhleE91dHB1dDogdHJ1ZSwgdGV4dElucHV0OiB0cnVlIH0sIG9wdGlvbnMpO1xuICAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYoaW5wdXQpO1xuICAgICAgaWYgKG9wdGlvbnMuaGV4T3V0cHV0KSB7XG4gICAgICAgIHJldHVybiBoYXNoLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5IZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgSE1BQyBvZiB0aGUgZ2l2ZW4gaW5wdXQgZGF0YSB3aXRoIHRoZSBnaXZlbiBrZXkgdXNpbmcgdGhlIFNIQS0yNTZcbiAgICAgKiBoYXNoIGFsZ29yaXRobS5cbiAgICAgKiBUaGUgb3B0aW9ucyBjYW4gYmUgdXNlZCB0byBjb250cm9sIHRoZSBpbi0vb3V0cHV0IG9mIHRoZSBoYXNoIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFNlY3JldCBrZXkuXG4gICAgICogQHBhcmFtIHsqfSBpbnB1dCBJbnB1dCBkYXRhLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0OlxuICAgICAqIGBoZXhPdXRwdXRgIC0tIE91dHB1dCB0aGUgaGFzaCB3aXRoIGhleCBlbmNvZGluZyAoZGVmYXVsdDogYHRydWVgKS5cbiAgICAgKiBgdGV4dElucHV0YCAtLSBJbnRlcnByZXQgdGhlIGlucHV0IGRhdGEgYXMgdGV4dCAoZGVmYXVsdDogYHRydWVgKS5cbiAgICAgKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIEhNQUMuXG4gICAgICovXG4gICAgaG1hYzogZnVuY3Rpb24gaG1hYyhrZXksIGlucHV0LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gZXh0ZW5kKHsgaGV4T3V0cHV0OiB0cnVlLCB0ZXh0SW5wdXQ6IHRydWUgfSwgb3B0aW9ucyk7XG4gICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEEyNTYoaW5wdXQsIGtleSwgeyBhc0J5dGVzOiB0cnVlIH0pO1xuICAgICAgaWYgKG9wdGlvbnMuaGV4T3V0cHV0KSB7XG4gICAgICAgIHJldHVybiBobWFjLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5IZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhtYWM7XG4gICAgfVxuICB9O1xufVxuXG4vLyBTaW1wbGUgdmVyc2lvbiBvZiB0aGUgYGV4dGVuZGAgZnVuY3Rpb24sIGtub3duIGZyb20gQW5ndWxhciBhbmQgQmFja2JvbmUuXG4vLyBJdCBtZXJnZXMgdGhlIHNlY29uZCAoYW5kIGFsbCBzdWNjZWVkaW5nKSBhcmd1bWVudChzKSBpbnRvIHRoZSBvYmplY3QsIGdpdmVuIGFzIGZpcnN0XG4vLyBhcmd1bWVudC4gVGhpcyBpcyBkb25lIHJlY3Vyc2l2ZWx5IGZvciBhbGwgY2hpbGQgb2JqZWN0cywgYXMgd2VsbC5cbmZ1bmN0aW9uIGV4dGVuZChkZXN0KSB7XG4gIHZhciBvYmpzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICBvYmpzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICghb2JqIHx8ICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmopKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBzcmMgPSBvYmpba2V5XTtcbiAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc3JjICE9PSBudWxsICYmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihzcmMpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZGVzdFtrZXldID0gQXJyYXkuaXNBcnJheShzcmMpID8gW10gOiB7fTtcbiAgICAgICAgZXh0ZW5kKGRlc3Rba2V5XSwgc3JjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlc3Rba2V5XSA9IHNyYztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBkZXN0O1xufVxuXG4vLyBUaHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIHVuZGVmaW5lZC5cbmZ1bmN0aW9uIGFzc2VydFJlcXVpcmVkKG9iaiwgbXNnKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyB8fCAhb2JqKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cblxudmFyIE1FVFJJQ1MgPSBbJ3NpemUnLCAnZHVyYXRpb24nLCAncG9zaXRpb24nLCAnbnVtYmVyJywgJ2NvdW50J107XG52YXIgREVGQVVMVF9FTkRQT0lOVCA9ICdodHRwczovL21vYmlsZWFuYWx5dGljcy51cy1lYXN0LTEuYW1hem9uYXdzLmNvbS8yMDE0LTA2LTA1L2V2ZW50cyc7XG5cbnZhciBBbWF6b24gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFtYXpvbihvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQW1hem9uKTtcblxuICAgIHRoaXMubmFtZSA9ICdhbWF6b24nO1xuICAgIF9leHRlbmRzKHRoaXMsIG9wdGlvbnMpO1xuICAgIHZhciBzZXNzaW9uID0gZ2V0VXNlcigpLnNlc3Npb247XG4gICAgaWYgKHNlc3Npb24ubmV3ICYmICFvcHRpb25zLnRlc3QpIHRoaXMubG9nRXZlbnQoeyBldmVudFR5cGU6ICdfc2Vzc2lvbi5zdGFydCcgfSk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhBbWF6b24sIFt7XG4gICAga2V5OiAnbG9nUGFnZVZpZXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2dQYWdlVmlldyhwYWdlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZXZlbnQgPSBjcmVhdGVQYWdlVmlldyhwYWdlLCB0aGlzLnByZXZpb3VzUGFnZSwgb3B0aW9ucyk7XG4gICAgICBzZW5kVGVsZW1ldHJ5KGV2ZW50LCB0aGlzLnVzZXJQb29sSUQsIHRoaXMuYXBwKTtcbiAgICAgIHRoaXMucHJldmlvdXNQYWdlID0gZXZlbnQuYXR0cmlidXRlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2dFdmVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvZ0V2ZW50KGV2ZW50KSB7XG4gICAgICB2YXIgZXZlbnRzID0gY3JlYXRlRXZlbnRMb2coZXZlbnQpO1xuICAgICAgc2VuZFRlbGVtZXRyeShldmVudHMsIHRoaXMudXNlclBvb2xJRCwgdGhpcy5hcHApO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQW1hem9uO1xufSgpO1xuXG5mdW5jdGlvbiBjcmVhdGVQYWdlVmlldyhwYWdlKSB7XG4gIHZhciBwcmV2aW91c1BhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgdmFyIHNlc3Npb24gPSBnZXRVc2VyKCkuc2Vzc2lvbjtcbiAgcmV0dXJuIHtcbiAgICBldmVudFR5cGU6ICdwYWdlVmlldycsXG4gICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgc2Vzc2lvbjoge1xuICAgICAgaWQ6IHNlc3Npb24uaWQsXG4gICAgICBzdGFydFRpbWVzdGFtcDogc2Vzc2lvbi5zdGFydFRpbWVzdGFtcFxuICAgIH0sXG4gICAgYXR0cmlidXRlczogX2V4dGVuZHMoe1xuICAgICAgcmVmZXJyZXI6IGRvY3VtZW50LnJlZmVycmVyLFxuICAgICAgaG9zdG5hbWU6IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSxcbiAgICAgIHBhdGg6IHBhZ2UgfHwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgcGFnZVVybDogcGFnZSB8fCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBwYWdlTmFtZTogZG9jdW1lbnQudGl0bGUsXG4gICAgICBwcmV2aW91c1BhZ2VVcmw6IHByZXZpb3VzUGFnZS5wYWdlVXJsLFxuICAgICAgcHJldmlvdXNQYWdlTmFtZTogcHJldmlvdXNQYWdlLnBhZ2VOYW1lXG4gICAgfSwgZXh0cmFjdEF0dHJpYnV0ZXMob3B0aW9ucykpLFxuICAgIG1ldHJpY3M6IGV4dHJhY3RNZXRyaWNzKG9wdGlvbnMpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50TG9nKGV2ZW50KSB7XG4gIHZhciBzZXNzaW9uID0gZ2V0VXNlcigpLnNlc3Npb247XG4gIHJldHVybiB7XG4gICAgZXZlbnRUeXBlOiBldmVudC5ldmVudFR5cGUgfHwgJ290aGVyJyxcbiAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBzZXNzaW9uOiB7XG4gICAgICBpZDogc2Vzc2lvbi5pZCxcbiAgICAgIHN0YXJ0VGltZXN0YW1wOiBzZXNzaW9uLnN0YXJ0VGltZXN0YW1wXG4gICAgfSxcbiAgICBhdHRyaWJ1dGVzOiBfZXh0ZW5kcyh7XG4gICAgICByZWZlcnJlcjogZG9jdW1lbnQucmVmZXJyZXIsXG4gICAgICBob3N0bmFtZTogd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLFxuICAgICAgcGF0aDogd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lXG4gICAgfSwgZXh0cmFjdEF0dHJpYnV0ZXMoZXZlbnQpKSxcbiAgICBtZXRyaWNzOiBleHRyYWN0TWV0cmljcyhldmVudClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEF0dHJpYnV0ZXMoZXZlbnQpIHtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBfZXh0ZW5kcyh7fSwgZXZlbnQpO1xuICBkZWxldGUgYXR0cmlidXRlcy53b3JrZmxvdztcbiAgTUVUUklDUy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRyaWMpIHtcbiAgICByZXR1cm4gZGVsZXRlIGF0dHJpYnV0ZXNbbWV0cmljXTtcbiAgfSk7XG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICBpZiAoYXR0ciA9PT0gJ2pzb24nKSB7XG4gICAgICBhdHRyaWJ1dGVzW2F0dHJdID0gYXR0cmlidXRlc1thdHRyXSA/IEpTT04uc3RyaW5naWZ5KGF0dHJpYnV0ZXNbYXR0cl0pIDogJ251bGwnO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRyaWJ1dGVzW2F0dHJdID0gYXR0cmlidXRlc1thdHRyXSAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlc1thdHRyXS50b1N0cmluZygpIDogJ251bGwnO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0TWV0cmljcyhldmVudCkge1xuICB2YXIgbWV0cmljcyA9IHt9O1xuICBNRVRSSUNTLmZvckVhY2goZnVuY3Rpb24gKG1ldHJpYykge1xuICAgIGlmIChldmVudFttZXRyaWNdKSBtZXRyaWNzW21ldHJpY10gPSBldmVudFttZXRyaWNdO1xuICB9KTtcbiAgcmV0dXJuIG1ldHJpY3M7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcnMoKSB7XG4gIHZhciBjcmVkZW50aWFscyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzWzFdO1xuXG4gIHZhciBjb25maWcgPSB7XG4gICAgcmVnaW9uOiAndXMtZWFzdC0xJyxcbiAgICBzZXJ2aWNlOiAnbW9iaWxlYW5hbHl0aWNzJyxcbiAgICBhY2Nlc3NLZXlJZDogY3JlZGVudGlhbHMuQWNjZXNzS2V5SWQsXG4gICAgc2VjcmV0QWNjZXNzS2V5OiBjcmVkZW50aWFscy5TZWNyZXRLZXksXG4gICAgc2Vzc2lvblRva2VuOiBjcmVkZW50aWFscy5TZXNzaW9uVG9rZW5cbiAgfTtcbiAgdmFyIHNpZ25lciA9IG5ldyBBd3NTaWduZXIoY29uZmlnKTtcbiAgdmFyIHNpZ25lZCA9IHNpZ25lci5zaWduKG9wdGlvbnMpO1xuICByZXR1cm4gc2lnbmVkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRDb250ZXh0KGNsaWVudElkLCBhcHApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgIGNsaWVudDoge1xuICAgICAgY2xpZW50X2lkOiBjbGllbnRJZCxcbiAgICAgIGFwcF90aXRsZTogYXBwLm5hbWUsXG4gICAgICBhcHBfdmVyc2lvbl9uYW1lOiBhcHAudmVyc2lvbiB8fCAndW5rbm93bidcbiAgICB9LFxuICAgIHNlcnZpY2VzOiB7XG4gICAgICBtb2JpbGVfYW5hbHl0aWNzOiB7XG4gICAgICAgIGFwcF9pZDogYXBwLmlkXG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VuZFRlbGVtZXRyeShldmVudHMsIHVzZXJQb29sSUQsIGFwcCkge1xuICB2YXIgdXNlciA9IGdldFVzZXIoKTtcbiAgZXZlbnRzID0gQXJyYXkuaXNBcnJheShldmVudHMpID8gZXZlbnRzIDogW2V2ZW50c107XG4gIHZhciBvcHRpb25zID0gY3JlYXRlVGVsZW1ldHJ5T3B0aW9ucyhldmVudHMpO1xuICBnZXRDcmVkZW50aWFscyh1c2VyUG9vbElELCBmdW5jdGlvbiAoY3JlZGVudGlhbHMpIHtcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzID0gY3JlYXRlSGVhZGVycyhjcmVkZW50aWFscywgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmhlYWRlcnNbJ3gtYW16LUNsaWVudC1Db250ZXh0J10gPSBjcmVhdGVDbGllbnRDb250ZXh0KHVzZXIuaWQsIGFwcCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVxdWVzdChvcHRpb25zLCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKEpTT04ucGFyc2UocmVzcG9uc2UpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRlbGVtZXRyeU9wdGlvbnMoZXZlbnRzKSB7XG4gIHZhciB1cmwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERFRkFVTFRfRU5EUE9JTlQ7XG5cbiAgcmV0dXJuIHtcbiAgICB1cmw6IHVybCxcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBldmVudHM6IGV2ZW50c1xuICAgIH0pXG4gIH07XG59XG5cbnZhciBHb29nbGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdvb2dsZSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgR29vZ2xlKTtcblxuICAgIHRoaXMubmFtZSA9ICdnb29nbGUnO1xuICAgIF9leHRlbmRzKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoR29vZ2xlLCBbe1xuICAgIGtleTogJ2xvZ1BhZ2VWaWV3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9nUGFnZVZpZXcocGFnZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHBhZ2V2aWV3T2JqID0gYnVpbGRQYWdlVmlld09iamVjdChwYWdlLCBvcHRpb25zLCB0aGlzLmRpbWVuc2lvbnMsIHRoaXMubWV0cmljcyk7XG4gICAgICBnZXRUcmFja2VycyhmdW5jdGlvbiAodHJhY2tlcnMpIHtcbiAgICAgICAgdHJhY2tlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tlcikge1xuICAgICAgICAgIHRyYWNrZXIuc2VuZChwYWdldmlld09iaik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9nRXZlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2dFdmVudChldmVudCkge1xuICAgICAgdmFyIGV2ZW50T2JqZWN0ID0gYnVpbGRFdmVudE9iamVjdChldmVudCwgdGhpcy5kaW1lbnNpb25zLCB0aGlzLm1ldHJpY3MpO1xuICAgICAgZ2V0VHJhY2tlcnMoZnVuY3Rpb24gKHRyYWNrZXJzKSB7XG4gICAgICAgIHRyYWNrZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrZXIpIHtcbiAgICAgICAgICB0cmFja2VyLnNlbmQoZXZlbnRPYmplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gR29vZ2xlO1xufSgpO1xuXG5mdW5jdGlvbiBnZXRUcmFja2VycyhjYWxsYmFjaykge1xuICBpZiAod2luZG93LmdhKSB7XG4gICAgd2luZG93LmdhKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKHdpbmRvdy5nYS5nZXRBbGwoKSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2cobmV3IEVycm9yKCdHb29nbGUgQW5hbHl0aWNzIHRyYWNrZXJzIG5vdCBhdmFpbGFibGUnKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRQYWdlVmlld09iamVjdChwYWdlLCBvcHRpb25zKSB7XG4gIHZhciBkaW1lbnNpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIG1ldHJpY3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gIHZhciBwYWdldmlld09iamVjdCA9IHtcbiAgICBoaXRUeXBlOiAncGFnZXZpZXcnLFxuICAgIHBhZ2U6IHBhZ2UgfHwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lXG4gIH07XG5cbiAgcmV0dXJuIG1hcE1ldHJpY3NBbmREaW1lbnNpb25zKHBhZ2V2aWV3T2JqZWN0LCBvcHRpb25zLCBkaW1lbnNpb25zLCBtZXRyaWNzKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRFdmVudE9iamVjdChldmVudCkge1xuICB2YXIgZGltZW5zaW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBtZXRyaWNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICB2YXIgZXZlbnRPYmplY3QgPSB7XG4gICAgaGl0VHlwZTogJ2V2ZW50JyxcbiAgICBldmVudENhdGVnb3J5OiBldmVudC5jYXRlZ29yeSB8fCAnbm9uZScsXG4gICAgZXZlbnRBY3Rpb246IGV2ZW50LmFjdGlvbixcbiAgICBldmVudExhYmVsOiBldmVudC5sYWJlbCxcbiAgICBub25JbnRlcmFjdGlvbjogZXZlbnQubm9uSW50ZXJhY3Rpb25cbiAgfTtcblxuICByZXR1cm4gbWFwTWV0cmljc0FuZERpbWVuc2lvbnMoZXZlbnRPYmplY3QsIGV2ZW50LCBkaW1lbnNpb25zLCBtZXRyaWNzKTtcbn1cblxuZnVuY3Rpb24gbWFwTWV0cmljc0FuZERpbWVuc2lvbnMoaW5wdXRPYmplY3QsIG9wdGlvbnMsIGRpbWVuc2lvbnMsIG1ldHJpY3MpIHtcbiAgdmFyIG1hcHBlZE9iamVjdCA9IGlucHV0T2JqZWN0O1xuXG4gIE9iamVjdC5rZXlzKGRpbWVuc2lvbnMpLmZvckVhY2goZnVuY3Rpb24gKGRpbWVuc2lvbikge1xuICAgIG1hcHBlZE9iamVjdFsnZGltZW5zaW9uJyArIGRpbWVuc2lvbnNbZGltZW5zaW9uXV0gPSBvcHRpb25zW2RpbWVuc2lvbl07XG4gIH0pO1xuXG4gIE9iamVjdC5rZXlzKG1ldHJpY3MpLmZvckVhY2goZnVuY3Rpb24gKG1ldHJpYykge1xuICAgIG1hcHBlZE9iamVjdFsnbWV0cmljJyArIG1ldHJpY3NbbWV0cmljXV0gPSBvcHRpb25zW21ldHJpY107XG4gIH0pO1xuXG4gIHJldHVybiBtYXBwZWRPYmplY3Q7XG59XG5cbnZhciBhbm9ueW1pemUgPSBmdW5jdGlvbiAodXNlcikge1xuICBpZiAoIXVzZXIpIHJldHVybiB1bmRlZmluZWQ7XG4gIHJldHVybiBDcnlwdG9KUy5TSEEyNTYodXNlcikudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLkhleCk7XG59O1xuXG52YXIgaW50ZXJuYWxPcmdzID0gWydlc3JpLmNvbScsICdlc3JpdWsuY29tJywgJ2VzcmkuZGUnLCAnZXNyaS5jYScsICdlc3JpZnJhbmNlLmZyJywgJ2VzcmkubmwnLCAnZXNyaS1wb3J0dWdhbC5wdCcsICdlc3JpYnVsZ2FyaWEuY29tJywgJ2VzcmkuZmknLCAnZXNyaS5rcicsICdlc3JpbWFsYXlzaWEuY29tLm15JywgJ2VzcmkuZXMnLCAnZXNyaWF1c3RyYWxpYS5jb20uYXUnLCAnZXNyaS1zb3V0aGFmcmljYS5jb20nLCAnZXNyaS5jbCcsICdlc3JpY2hpbmEuY29tLmNuJywgJ2VzcmkuY28nLCAnZXNyaXR1cmtleS5jb20udHInLCAnZ2VvZGF0YS5ubycsICdlc3JpaXRhbGlhLml0JywgJ2VzcmkucGwnXTtcblxuLypcbiAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIHRlbGVtZXRyeSBsaWJyYXJ5IHNob3VsZCBiZSBlbmFibGVkIGJhc2VkIG9uIHBhc3NlZCBpbiBvcHRpb25zXG4gKi9cbnZhciB0ZWxlbWV0cnlFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgdmFyIHBvcnRhbCA9IG9wdGlvbnMucG9ydGFsIHx8IHt9O1xuICBpZiAob3B0aW9ucy5kaXNhYmxlZCkge1xuICAgIC8vIFRyYWNraW5nIGlzIG1hbnVhbGx5IGRpc2FibGVkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKG5hdmlnYXRvci5kb05vdFRyYWNrID09PSAnMScgfHwgd2luZG93LmRvTm90VHJhY2sgPT09ICcxJykge1xuICAgIC8vIHVzZXIncyBicm93c2VyIGhhcyB0dXJuZWQgb2ZmIHRyYWNraW5nXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwb3J0YWwuZXVlaUVuYWJsZWQgIT09ICd1bmRlZmluZWQnICYmIHBvcnRhbC5ldWVpRW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAvLyBQb3J0YWwgZG9lcyBub3QgYWxsb3cgdHJhY2tpbmdcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAocG9ydGFsLmV1ZWlFbmFibGVkICYmIHBvcnRhbC51c2VyICYmIHBvcnRhbC51c2VyLm9yZ0lkID09PSBwb3J0YWwuaWQpIHtcbiAgICAvLyBQb3J0YWwgYWxsb3dzIHRyYWNraW5nOyBleGNlcHQgd2hlbiB1c2VyIGlzIGFub255bW91cyBvciBkb2Vzbid0IGJlbG9uZyB0byBwb3J0YWwncyBvcmdcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChwb3J0YWwudXNlciAmJiAhcG9ydGFsLnVzZXIub3JnSWQgJiYgcG9ydGFsLmlwQ250cnlDb2RlID09PSAnVVMnKSB7XG4gICAgLy8gUHVibGljIHVzZXIgaW4gdGhlIFVuaXRlZCBTdGF0ZXMgb24gYSBwb3J0YWwgdGhhdCBhbGxvd3MgdHJhY2tpbmdcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICghcG9ydGFsLnVzZXIgJiYgcG9ydGFsLmlwQ250cnlDb2RlID09PSAnVVMnKSB7XG4gICAgLy8gQW5vbnltb3VzIHVzZXIgaW4gdGhlIFVuaXRlZCBTdGF0ZXMgb24gYSBwb3J0YWwgdGhhdCBhbGxvd3MgdHJhY2tpbmdcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChPYmplY3Qua2V5cyhwb3J0YWwpLmxlbmd0aCA+IDApIHtcbiAgICAvLyBJbml0aWFsaXplZCB3aXRoIGEgUG9ydGFsIG9iamVjdCBidXQgZG9lcyBub3QgbWVldCB0cmFja2luZyBjb25kaXRpb25zXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIC8vIERlZmF1bHQgY29uZGl0aW9uIG5vdCBpbml0aWFsaXplZCB3aXRoIGEgUG9ydGFsLVNlbGYgb2JqZWN0XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbnZhciBUZWxlbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRlbGVtZXRyeShvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGVsZW1ldHJ5KTtcblxuICAgIC8vIE1ha2Ugc3VyZSBmYWlsdXJlIHRvIGluaXQgdGhpcyBsaWJyYXJ5IGNhbm5vdCBoYXZlIHNpZGUtZWZmZWN0c1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnRyYWNrZXJzID0gW107XG4gICAgICB0aGlzLndvcmtmbG93cyA9IHt9O1xuICAgICAgdGhpcy50ZXN0ID0gb3B0aW9ucy50ZXN0O1xuICAgICAgdGhpcy5kZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG5cbiAgICAgIHRoaXMuZGlzYWJsZWQgPSAhdGVsZW1ldHJ5RW5hYmxlZChvcHRpb25zKTtcbiAgICAgIGlmICh0aGlzLmRpc2FibGVkKSBjb25zb2xlLmxvZygnVGVsZW1ldHJ5IERpc2FibGVkJyk7XG5cbiAgICAgIGlmIChvcHRpb25zLnBvcnRhbCAmJiBvcHRpb25zLnBvcnRhbC51c2VyKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25JbmZvID0gb3B0aW9ucy5wb3J0YWwuc3Vic2NyaXB0aW9uSW5mbyB8fCB7fTtcbiAgICAgICAgdGhpcy5zZXRVc2VyKG9wdGlvbnMucG9ydGFsLnVzZXIsIHN1YnNjcmlwdGlvbkluZm8udHlwZSk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMudXNlcikge1xuICAgICAgICB0aGlzLnNldFVzZXIob3B0aW9ucy51c2VyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuX2luaXRUcmFja2VycyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUZWxlbWV0cnkgRGlzYWJsZWQnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBjcmVhdGVDbGFzcyhUZWxlbWV0cnksIFt7XG4gICAga2V5OiAnX2luaXRUcmFja2VycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0VHJhY2tlcnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMuYW1hem9uKSB7XG4gICAgICAgIHZhciBhbWF6b24gPSBuZXcgQW1hem9uKG9wdGlvbnMuYW1hem9uKTtcbiAgICAgICAgdGhpcy50cmFja2Vycy5wdXNoKGFtYXpvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmdvb2dsZSkge1xuICAgICAgICB2YXIgZ29vZ2xlID0gbmV3IEdvb2dsZShvcHRpb25zLmdvb2dsZSk7XG4gICAgICAgIHRoaXMudHJhY2tlcnMucHVzaChnb29nbGUpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnRyYWNrZXJzLmxlbmd0aCkgY29uc29sZS5lcnJvcihuZXcgRXJyb3IoJ05vIHRyYWNrZXJzIGNvbmZpZ3VyZWQnKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0VXNlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFVzZXIoKSB7XG4gICAgICB2YXIgdXNlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICB2YXIgb3JnVHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ1B1YmxpYyc7XG5cbiAgICAgIHVzZXIgPSB0eXBlb2YgdXNlciA9PT0gJ3N0cmluZycgPyB7IHVzZXJuYW1lOiB1c2VyIH0gOiB1c2VyO1xuICAgICAgdGhpcy51c2VyID0gdXNlcjtcbiAgICAgIHRoaXMudXNlci5hY2NvdW50VHlwZSA9IG9yZ1R5cGU7XG4gICAgICB2YXIgaW50ZXJuYWxEb21haW4gPSB2b2lkIDA7XG4gICAgICBpZiAodXNlci5lbWFpbCAmJiB1c2VyLmVtYWlsLnNwbGl0KSB7XG4gICAgICAgIHZhciBkb21haW4gPSB1c2VyLmVtYWlsLnNwbGl0KCdAJylbMV07XG4gICAgICAgIGludGVybmFsRG9tYWluID0gaW50ZXJuYWxPcmdzLmZpbHRlcihmdW5jdGlvbiAob3JnKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbWFpbiA9PT0gb3JnO1xuICAgICAgICB9KS5sZW5ndGggPiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW50ZXJuYWxEb21haW4gfHwgWydJbiBIb3VzZScsICdEZW1vIGFuZCBNYXJrZXRpbmcnXS5pbmRleE9mKG9yZ1R5cGUpID4gLTEpIHtcbiAgICAgICAgdGhpcy51c2VyLmludGVybmFsVXNlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9nUGFnZVZpZXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2dQYWdlVmlldyhwYWdlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5wcmVQcm9jZXNzKG9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMuZGVidWcpIGNvbnNvbGUubG9nKCdUcmFja2luZyBwYWdlIHZpZXcnLCBKU09OLnN0cmluZ2lmeShhdHRyaWJ1dGVzKSk7ZWxzZSBpZiAodGhpcy50ZXN0ICYmICF0aGlzLmRpc2FibGVkKSByZXR1cm4gYXR0cmlidXRlcztcblxuICAgICAgaWYgKCF0aGlzLnRyYWNrZXJzLmxlbmd0aCB8fCB0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkgY29uc29sZS5lcnJvcihuZXcgRXJyb3IoJ1BhZ2UgdmlldyB3YXMgbm90IGxvZ2dlZCBiZWNhdXNlIG5vIHRyYWNrZXJzIGFyZSBjb25maWd1cmVkLicpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmFja2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja2VyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRyYWNrZXIubG9nUGFnZVZpZXcocGFnZSwgYXR0cmlidXRlcyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcih0cmFja2VyLm5hbWUgKyAnIHRyYWNrZXIgZmFpbGVkIHRvIGxvZyBwYWdlIHZpZXcuJywgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9nRXZlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2dFdmVudCgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgdmFyIGV2ZW50ID0gdGhpcy5wcmVQcm9jZXNzKG9wdGlvbnMpO1xuXG4gICAgICBpZiAodGhpcy5kZWJ1ZykgY29uc29sZS5sb2coJ1RyYWNraW5nIGV2ZW50JywgSlNPTi5zdHJpbmdpZnkoZXZlbnQpKTtlbHNlIGlmICh0aGlzLnRlc3QpIHJldHVybiBldmVudDtcblxuICAgICAgaWYgKCF0aGlzLnRyYWNrZXJzLmxlbmd0aCB8fCB0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkgY29uc29sZS5lcnJvcihuZXcgRXJyb3IoJ0V2ZW50IHdhcyBub3QgbG9nZ2VkIGJlY2F1c2Ugbm8gdHJhY2tlcnMgYXJlIGNvbmZpZ3VyZWQuJykpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRyYWNrZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrZXIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdHJhY2tlci5sb2dFdmVudChldmVudCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcih0cmFja2VyLm5hbWUgKyAnIHRyYWNrZXIgZmFpbGVkIHRvIGxvZyBldmVudCcsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvZ0Vycm9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9nRXJyb3IoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIHZhciBldmVudCA9IF9leHRlbmRzKHsgZXZlbnRUeXBlOiAnZXJyb3InIH0sIG9wdGlvbnMpO1xuICAgICAgdGhpcy5sb2dFdmVudChldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RhcnRXb3JrZmxvdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0V29ya2Zsb3cobmFtZSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICB2YXIgd29ya2Zsb3cgPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHN0YXJ0OiBEYXRlLm5vdygpLFxuICAgICAgICBzdGVwczogW10sXG4gICAgICAgIHdvcmtmbG93SWQ6IE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDAwMDAwMDAwKS50b1N0cmluZygxNilcbiAgICAgIH07XG4gICAgICB0aGlzLl9zYXZlV29ya2Zsb3cod29ya2Zsb3cpO1xuICAgICAgdmFyIHdvcmtmbG93T2JqID0gX2V4dGVuZHMoeyBuYW1lOiBuYW1lLCBzdGVwOiAnc3RhcnQnIH0sIGF0dHJpYnV0ZXMpO1xuICAgICAgdGhpcy5fbG9nV29ya2Zsb3cod29ya2Zsb3dPYmopO1xuICAgICAgcmV0dXJuIHdvcmtmbG93O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0ZXBXb3JrZmxvdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0ZXBXb3JrZmxvdyhuYW1lLCBzdGVwKSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIHZhciBkZXRhaWxzID0gdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnID8gYXR0cmlidXRlcyA6IGF0dHJpYnV0ZXMuZGV0YWlscztcbiAgICAgIHZhciB3b3JrZmxvd09iaiA9IF9leHRlbmRzKHsgbmFtZTogbmFtZSwgc3RlcDogc3RlcCwgZGV0YWlsczogZGV0YWlscyB9LCBhdHRyaWJ1dGVzKTtcbiAgICAgIHRoaXMuX2xvZ1dvcmtmbG93KHdvcmtmbG93T2JqKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbmRXb3JrZmxvdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZFdvcmtmbG93KG5hbWUpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgdmFyIHdvcmtmbG93T2JqID0gX2V4dGVuZHMoeyBuYW1lOiBuYW1lLCBzdGVwOiAnZmluaXNoJyB9LCBhdHRyaWJ1dGVzKTtcbiAgICAgIHRoaXMuX2xvZ1dvcmtmbG93KHdvcmtmbG93T2JqKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYW5jZWxXb3JrZmxvdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbFdvcmtmbG93KG5hbWUpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgdmFyIHdvcmtmbG93T2JqID0gX2V4dGVuZHMoeyBuYW1lOiBuYW1lLCBzdGVwOiAnY2FuY2VsJyB9LCBhdHRyaWJ1dGVzKTtcbiAgICAgIHRoaXMuX2xvZ1dvcmtmbG93KHdvcmtmbG93T2JqKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRXb3JrZmxvdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdvcmtmbG93KG5hbWUpIHtcbiAgICAgIHZhciB3b3JrZmxvdyA9IFN0b3JhZ2UuZ2V0KCdURUxFTUVUUlktV09SS0ZMT1c6JyArIG5hbWUpO1xuICAgICAgLy8gZG8gbm90IGxldCBvbGQgd29ya2Zsb3dzIGJlIHJldHVybmVkXG4gICAgICBpZiAod29ya2Zsb3cpIHtcbiAgICAgICAgdmFyIHdvcmtmbG93QWdlID0gRGF0ZS5ub3coKSAtIHdvcmtmbG93LnN0YXJ0O1xuICAgICAgICB2YXIgdGltZW91dCA9IDMwICogNjAgKiAxMDAwO1xuICAgICAgICBpZiAod29ya2Zsb3dBZ2UgPCB0aW1lb3V0KSB7XG4gICAgICAgICAgcmV0dXJuIHdvcmtmbG93O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2RlbGV0ZVdvcmtmbG93KHdvcmtmbG93KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19zYXZlV29ya2Zsb3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2F2ZVdvcmtmbG93KHdvcmtmbG93KSB7XG4gICAgICBTdG9yYWdlLnNldCgnVEVMRU1FVFJZLVdPUktGTE9XOicgKyB3b3JrZmxvdy5uYW1lLCB3b3JrZmxvdyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2RlbGV0ZVdvcmtmbG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZVdvcmtmbG93KHdvcmtmbG93KSB7XG4gICAgICBTdG9yYWdlLmRlbGV0ZSgnVEVMRU1FVFJZLVdPUktGTE9XOicgKyB3b3JrZmxvdy5uYW1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfbG9nV29ya2Zsb3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9nV29ya2Zsb3coKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIC8qXG4gICAgICBjb25zdCB3b3JrZmxvdyA9IHtcbiAgICAgICAgbmFtZTogJ2FkZCBsYXllciB0byBtYXAnLFxuICAgICAgICBzdGVwOiAnc3RhcnQnLFxuICAgICAgICBkZXRhaWxzOiAnc29tZSBkZXRhaWxzIGFib3V0IHRoZSBzdGVwJ1xuICAgICAgfVxuICAgICAgKi9cbiAgICAgIG9wdGlvbnMgPSB0aGlzLnByZVByb2Nlc3Mob3B0aW9ucyk7XG4gICAgICB2YXIgd29ya2Zsb3cgPSB0aGlzLmdldFdvcmtmbG93KG9wdGlvbnMubmFtZSk7XG4gICAgICBpZiAoIXdvcmtmbG93KSB7XG4gICAgICAgIHRoaXMuc3RhcnRXb3JrZmxvdyhvcHRpb25zLm5hbWUpO1xuICAgICAgICB3b3JrZmxvdyA9IHRoaXMuZ2V0V29ya2Zsb3cob3B0aW9ucy5uYW1lKTtcbiAgICAgIH1cbiAgICAgIHdvcmtmbG93LnN0ZXBzLnB1c2gob3B0aW9ucy5zdGVwKTtcbiAgICAgIHdvcmtmbG93LmR1cmF0aW9uID0gKERhdGUubm93KCkgLSB3b3JrZmxvdy5zdGFydCkgLyAxMDAwO1xuXG4gICAgICBpZiAoWydjYW5jZWwnLCAnZmluaXNoJ10uaW5kZXhPZihvcHRpb25zLnN0ZXApID4gLTEpIHtcbiAgICAgICAgdGhpcy5fZGVsZXRlV29ya2Zsb3cod29ya2Zsb3cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2F2ZVdvcmtmbG93KHdvcmtmbG93KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYWNrID0gX2V4dGVuZHMob3B0aW9ucywge1xuICAgICAgICBldmVudFR5cGU6ICd3b3JrZmxvdycsXG4gICAgICAgIGNhdGVnb3J5OiBvcHRpb25zLm5hbWUsXG4gICAgICAgIGFjdGlvbjogb3B0aW9ucy5zdGVwLFxuICAgICAgICBsYWJlbDogb3B0aW9ucy5kZXRhaWxzLFxuICAgICAgICBkdXJhdGlvbjogd29ya2Zsb3cuZHVyYXRpb24sXG4gICAgICAgIHdvcmtmbG93SWQ6IHdvcmtmbG93LndvcmtmbG93SWRcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmxvZ0V2ZW50KHRyYWNrKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwcmVQcm9jZXNzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlUHJvY2VzcygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgdmFyIHVzZXJPcHRpb25zID0ge307XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHVzZXJPcHRpb25zID0ge1xuICAgICAgICAgIHVzZXI6IGFub255bWl6ZSh0aGlzLnVzZXIudXNlcm5hbWUpLFxuICAgICAgICAgIG9yZzogYW5vbnltaXplKHRoaXMudXNlci5vcmdJZCksXG4gICAgICAgICAgbGFzdExvZ2luOiB0aGlzLnVzZXIubGFzdExvZ2luLFxuICAgICAgICAgIHVzZXJTaW5jZTogdGhpcy51c2VyLmNyZWF0ZWQsXG4gICAgICAgICAgaW50ZXJuYWxVc2VyOiB0aGlzLnVzZXIuaW50ZXJuYWxVc2VyIHx8IGZhbHNlLFxuICAgICAgICAgIGFjY291bnRUeXBlOiB0aGlzLnVzZXIuYWNjb3VudFR5cGVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBvcHRpb25zLCB1c2VyT3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUZWxlbWV0cnk7XG59KCk7XG5cbnJldHVybiBUZWxlbWV0cnk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZWxlbWV0cnkuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxVQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@esri/telemetry/dist/telemetry.js\n");

/***/ })

/******/ })
			);
		}
	};
});